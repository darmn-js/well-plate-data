!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).wellPlateData={})}(this,(function(e){"use strict";const t=Object.prototype.toString;function r(e){return t.call(e).endsWith("Array]")}function a(e){return function(e){if(!r(e))throw new TypeError("input must be an array");if(0===e.length)throw new TypeError("input must not be empty");for(var t=0,a=0;a<e.length;a++)t+=e[a];return t}(e)/e.length}function s(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!r(e))throw new TypeError("input must be an array");for(var s=t.unbiased,l=void 0===s||s,n=t.mean,o=void 0===n?a(e):n,i=0,h=0;h<e.length;h++){var c=e[h]-o;i+=c*c}return l?i/(e.length-1):i/e.length}var l={confidence:{alphas:[.1,.075,.05,.025,.01],confidenceLevel:[90,92.5,95,97.5,99],significanceLevel:[10,7.5,5,2.5,1]},table:[[1.15,1.15,1.15,1.15,1.15],[1.42,1.44,1.46,1.48,1.49],[1.6,1.64,1.67,1.71,1.75],[1.73,1.77,1.82,1.89,1.94],[1.83,1.88,1.94,2.02,2.1],[1.91,1.96,2.03,2.13,2.22],[1.98,2.04,2.11,2.21,2.32],[2.03,2.1,2.18,2.29,2.41],[2.09,2.14,2.23,2.36,2.48],[2.13,2.2,2.29,2.41,2.55],[2.17,2.24,2.33,2.46,2.61],[2.21,2.28,2.37,2.51,2.66],[2.25,2.32,2.41,2.55,2.71],[2.28,2.35,2.44,2.59,2.75],[2.31,2.38,2.47,2.62,2.79],[2.34,2.41,2.5,2.65,2.82],[2.36,2.44,2.53,2.68,2.85],[2.38,2.46,2.56,2.71,2.88],[0,0,2.58,2.73,2.91],[0,0,2.6,2.76,2.94],[0,0,2.62,2.78,2.96],[0,0,2.64,2.8,2.99],[0,0,2.66,2.82,3.01],[0,0,2.68,2.84,999],[0,0,2.7,2.86,999],[0,0,2.72,2.88,999],[0,0,2.73,2.9,999],[0,0,2.75,2.91,999],[0,0,2.76,2.93,999],[0,0,2.78,2.95,999],[0,0,2.79,2.96,999],[0,0,2.81,2.97,999],[0,0,2.82,2.98,999],[0,0,2.83,2.992,999],[0,0,2.84,3.004,999],[0,0,2.85,3.016,999],[0,0,2.86,3.028,999],[0,0,2.87,3.04,999],[0,0,2.88,3.05,999],[0,0,2.89,3.06,999],[0,0,2.9,3.07,999],[0,0,2.91,3.08,999],[0,0,2.92,3.09,999],[0,0,2.928,3.098,999],[0,0,2.936,3.106,999],[0,0,2.944,3.114,999],[0,0,2.952,3.122,999],[0,0,2.967,3.137,999],[0,0,2.974,3.144,999],[0,0,2.981,3.151,999],[0,0,2.988,3.158,999],[0,0,2.995,3.165,999],[0,0,3.002,3.172,999],[0,0,3.009,3.179,999],[0,0,3.016,3.186,999],[0,0,3.023,3.193,999],[0,0,3.03,3.2,999],[0,0,3.036,3.206,999],[0,0,3.042,3.212,999],[0,0,3.048,3.218,999],[0,0,3.054,3.224,999],[0,0,3.06,3.23,999],[0,0,3.066,3.236,999],[0,0,3.072,3.242,999],[0,0,3.078,3.248,999],[0,0,3.084,3.254,999],[0,0,3.09,3.26,999],[0,0,3.095,3.265,999],[0,0,3.1,3.27,999],[0,0,3.105,3.275,999],[0,0,3.11,3.28,999],[0,0,3.115,3.285,999],[0,0,3.12,3.29,999],[0,0,3.125,3.295,999],[0,0,3.13,3.3,999],[0,0,3.135,3.305,999],[0,0,3.14,3.31,999],[0,0,3.144,3.314,999],[0,0,3.148,3.318,999],[0,0,3.152,3.322,999],[0,0,3.156,3.326,999],[0,0,3.16,3.33,999],[0,0,3.164,3.334,999],[0,0,3.168,3.338,999],[0,0,3.172,3.342,999],[0,0,3.176,3.346,999],[0,0,3.18,3.35,999],[0,0,3.183,3.353,999],[0,0,3.186,3.356,999],[0,0,3.189,3.359,999],[0,0,3.192,3.362,999],[0,0,3.195,3.365,999],[0,0,3.198,3.368,999],[0,0,3.201,3.371,999],[0,0,3.204,3.374,999],[0,0,3.207,3.377,999],[0,0,3.21,3.38,999]]};const{table:n,confidence:o}=l;function i(e,t={}){const{type:r="alphas",value:l=.05}=t,i=a(e),h=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Math.sqrt(s(e,t))}(e),c=[];if(e.length<3){for(const t of e)c.push({value:t,score:0,pass:void 0});return{criticalValue:void 0,test:c}}const u=n[e.length-3][o[r].indexOf(l)];for(const t of e){const e=Math.abs(t-i)/h;c.push({value:t,score:e,pass:!(e>u)})}return{criticalValue:u,test:c}}function h(e={}){const{length:t=25}=e;let r=[],a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",s=a.length;for(let e=0;e<t;e++)r.push(a.charAt(Math.floor(Math.random()*s)));return r.join("")}class c{constructor(e={}){let{id:t=h(),label:r,wells:a=[],metadata:s={color:"blue",display:!0,category:null,group:null},averagedSpectra:l={x:[],y:[]},averagedGrowthCurves:n={x:[],y:[]},_highlight:o=h(),analysis:i={raw:{},averaged:[],wells:[]},results:c={},reagents:u=[]}=e;this.id=t,this.label=r,this.wells=a,this.metadata=s,this.results=c,this.analysis=i,this.reagents=u,this.averagedSpectra=l,this.averagedGrowthCurves=n,this._highlight=o}}function u(e,t){e.styles={unselected:{lineColor:t.metadata.color||"red",lineWidth:1,lineStyle:1},selected:{lineColor:t.metadata.color||"red",lineWidth:3,lineStyle:1}},e.label=t.id}function d(e){const t=Object.keys(e[0].analysis.processed);let r=[];for(let a of t){let t=0;for(let r of e)t+=r.analysis.processed[a];r.push({label:a,value:t/e.length})}return r}function p(e){const t=[];for(let r of e)r.x&&r.y&&r.y.length&&t.push(r);if(!t.length)return{x:[],y:[]};let r=[],a=t[0].x;for(let e=0;e<t[0].y.length;e++){let a=0;for(let r=0;r<t.length;r++)t[r].y.length&&(a+=t[r].y[e]);r.push(a/t.length)}return{x:a,y:r}}function f(e,t={}){const{checkKeys:r=!0,checkValues:a=!0,keys:s=["reference","batch","uuid","concentration"]}=t,l=e.reagents;if(0===l.length)throw new Error(`The well ${e.id} has no reagents`);for(let t of l){const l=Object.entries(t);if(r){const r=l.map((e=>e[0]));for(let a=0;a<s.length;a++){if(!r.find((e=>e===s[a])))throw new Error(`Property ${s[a].toUpperCase()} not defined for ${t.label} at ${e.id}`)}}if(a){const r=l.map((e=>e[1]));for(let a=0;a<s.length;a++){const a=r.findIndex((e=>null==e||""===e));if(-1!==a)throw new Error(`Property ${l[a][0].toUpperCase()} has undefined value for ${t.label} at ${e.id}`)}}}}function g(e){const t=Object.keys(e[0].analysis.processed);let r={};for(let a of t){let t=0;for(let r of e)t+=r.analysis.processed[a];r[a]=t/e.length}return r}function y(e,t={}){const{path:r="id"}=t;return e.sort(((e,t)=>e[r].localeCompare(t[r],"en",{numeric:!0})))}class m{constructor(e={}){let{id:t=h(),label:r,plate:a,metadata:s={color:"black",display:!0,category:null,group:null},reagents:l=[],analysis:n={raw:{},processed:{}},growthCurve:o={data:{x:[],y:[]}},spectrum:i={data:{x:[],y:[]}}}=e;this.id=t,this.selected=!1,this.label=r,this.plate=a,this.analysis=n,this.metadata=s,this.reagents=l,this.growthCurve=o,this.spectrum=i,o.data.x||o.data.y||(this.growthCurve.data.x=[],this.growthCurve.data.y=[]),i.data.x||i.data.y||(this.spectrum.data.x=[],this.spectrum.data.y=[]),this._highlight=t}getGrowthCurve(){return this.growthCurve}getSpectrum(){return this.spectrum}getMetadata(){return this.metadata}getReagents(){return this.reagents}getLabel(){return this.label}getID(){return this.id}addGrowthCurve(e){if(!Array.isArray(e.x)||!Array.isArray(e.y))throw new Error("X and Y must be arrays");this.growthCurve={data:e}}addSpectrum(e){if(!Array.isArray(e.x)||!Array.isArray(e.y))throw new Error("X and Y must be arrays");this.spectrum={data:e}}addReagents(e){if(!Array.isArray(e))throw new Error("Reagents must be a vector of objects");if(0===this.reagents.length)this.reagents=e;else{let t=[];for(let r=0;r<e.length;r++){let a=this.reagents[r]?this.reagents[r]:{};t.push(Object.assign({},a,e[r]))}this.reagents=t}}updateReagents(e){if(!Array.isArray(e))throw new Error("Reagents must be a vector of objects");let t=[];for(let r of e){let e=this.reagents.filter((e=>e.label===r.label))[0];t.push(Object.assign({},e,r))}this.reagents=t}addAnalysis(e){if(Array.isArray(e)||"object"!=typeof e)throw new Error("Result must be a object");let{name:t,value:r}=e;this.analysis.raw[t]=r,this.analysis.processed[t]=r}}class w{constructor(e={}){this.wells=[],this.samples=[],this.typeOfPlate=function(e={}){const{nbRows:t="h",nbColumns:r="12"}=e;return`${Number.isNaN(parseInt(t,10))?t.toUpperCase():parseInt(t,10)}x${Number.isNaN(parseInt(r,10))?r.toUpperCase():parseInt(r,10)}`}(e);const t=function(e={}){let{nbRows:t="h",nbColumns:r="12",nbPlates:a=1,initPlate:s=0,accountPreviousWells:l=!1,direction:n="horizontal"}=e,o=Object.entries({rows:t,columns:r});for(let e=0;e<o.length;e++)if(Number.isNaN(parseInt(o[e][1],10))){let t=o[e][1].toUpperCase().charCodeAt(0),r=new Array(t-64).fill().map(((e,t)=>String.fromCharCode(t+65)));o[e][1]=r}else{let t=new Array(parseInt(o[e][1],10)).fill().map(((e,t)=>t+1));o[e][1]=t}let i=[],[h,c]=[o[0][1],o[1][1]];if(Number.isInteger(h[0])&&Number.isInteger(c[0])){let e="vertical"===n?h:c;for(let t=s;t<s+a;t++)for(let r=0;r<h.length;r++){let a=[];for(let s=0;s<c.length;s++){let[o,i]="vertical"===n?[r,s]:[s,r],u=l?t*h.length*c.length:0;a[s]=`${t+1}-${u+(i*e.length+e[o])}`}i.push(...a)}}else for(let e=s;e<s+a;e++)for(let t=0;t<h.length;t++){let r=[];for(let a=0;a<c.length;a++){let s="string"==typeof h[t]?h[t]+c[a]:c[a]+h[t];r[a]=`${e+1}-${s}`}i.push(...r)}return{labelsList:i,axis:o}}(e).labelsList;for(let e=0;e<t.length;e++){const r=t[e].split("-");this.wells.push(new m({id:t[e],plate:r[0],label:r[1],_highlight:e}))}}addReagentsFromArray(e){if(!Array.isArray(e)||this.wells.length!==e.length)throw new Error("Input array must have the same length as wells in the plate");for(let t=0;t<this.wells.length;t++)this.wells[t].addReagents(e[t]);this.updateSamples()}addSpectrumFromArray(e){if(!Array.isArray(e))throw new Error("Input array must have the same length as wells in the plate");if(!Array.isArray(e)||!Array.isArray(e[0].array.x)||!Array.isArray(e[0].array.y)||e[0].array.y.length!==e[0].array.x.length)throw new Error("The input array must be an array");for(let t of this.wells){const r=e.filter((e=>e.label===t.label))[0];void 0!==r?(t.metadata.display=!1,t.metadata.color="black",t.addSpectrum(r.array)):(t.metadata.display=!1,t.metadata.color="darkgrey")}this.updateSamples()}addGrowthCurvesFromArray(e){if(!Array.isArray(e))throw new Error("The input array must be an array");if(!Array.isArray(e)||!Array.isArray(e[0].array.x)||!Array.isArray(e[0].array.y)||e[0].array.y.length!==e[0].array.x.length)throw new Error("The input array must be an array of objects with x and y components");for(let t of this.wells){const r=e.filter((e=>e.label===t.label))[0];void 0!==r?(t.metadata.display=!1,t.metadata.color="black",t.addGrowthCurve(r.array)):(t.metadata.display=!1,t.metadata.color="darkgrey")}this.updateSamples()}addAnalysisFromArray(e){if(!Array.isArray(e))throw new Error("The analysis input is not an array");for(let t=0;t<this.wells.length;t++)this.wells[t].addAnalysis(e[t])}getWells(e={}){const{ids:t}=e;let r=[];for(let e of this.wells)t&&!t.includes(e.id)||r.push(e);return r}getWell(e={}){const{id:t}=e;for(let e of this.wells)if(t===e.id)return e}getTemplate(e={}){const{separator:t=","}=e,r=this.wells,a=/(?:[0-9]+)|(?:[a-zA-Z]+)/g,s=r[0].reagents.map((e=>e.label)),l=r[0].reagents.map((e=>e.unit)),n=[];for(let e=0;e<s.length;e++)n.push(`${s[e]}(${l[e]})`);const o=[["row","column"].concat(n)];for(let e of r){const t=Number.isNaN(parseInt(e.label,10))?e.label.match(a):b(e.label),r=e.reagents.map((e=>e.concentration));o.push(t.concat(r))}return o.map((e=>e.join(t))).join("\n")}checkReagents(e={}){const t=this.wells;for(let r of t)f(r,e)}getSpectraChart(e={}){const{ids:t}=e,r=this.wells;let a={data:[]};for(let e of r)if((!t||t.includes(e.id))&&e.spectrum.data.x.length&&e.spectrum.data.y.length){const t=e.spectrum.data;u(t,e),a.data.push(t)}return a}getGrowthCurveChart(e={}){const{ids:t}=e,r=this.wells;let a={data:[]};for(let e of r)if((!t||t.includes(e.id))&&e.growthCurve.data.x.length&&e.growthCurve.data.y.length){const t=e.growthCurve.data;u(t,e),a.data.push(t)}return a}getChartOfSpectraSamples(e){let t={data:[]},r=this.getSamples(e);for(let e of r){const r=e.averagedSpectra;u(r,e),t.data.push(r)}return t}getChartOfGrowthCurvesSamples(e){let t={data:[]},r=this.getSamples(e);for(let e of r){const r=e.averagedGrowthCurves;u(r,e),t.data.push(r)}return t}getSamples(e={}){const{ids:t}=e;let r=[];for(let e of this.samples)t&&!t.includes(e.id)||r.push(e);return r}getSample(e={}){const{id:t}=e;for(let e of this.samples)if(t===e.id)return e}static fillPlateFromArray(e){e=y(e);const t=y(e,{path:"label"})[e.length-1].label;let[r,a]=Number.isNaN(parseInt(t,10))?t.match(/[^\d]+|\d+/g):[10,10];const s=parseInt(e[e.length-1].id.split("-")[0],10),l=new w({nbRows:r,nbColumns:a,nbPlates:s});for(let t of e){const e=l.wells.findIndex((e=>e.id===t.id));l.wells[e]=new m(t)}return l.typeOfPlate=`${r}x${a}`,l.updateSamples(),l}static readTemplate(e,t={}){const{separator:r=","}=t,a=e.split("\n").map((e=>e.split(r))).filter((e=>""!==e)),s=[];let l;if(Number.isInteger(parseInt(a[1][0],10))&&Number.isInteger(parseInt(a[1][1],10))){l=new w({nbRows:10,nbColumns:10});for(let e=1;e<a.length;e++){const t={id:`1-${10*(parseInt(a[e][0],10)-1)+parseInt(a[e][1],10)}`,reagents:[]};for(let r=2;r<a[0].length;r++)t.reagents.push({label:a[0][r].split("(")[0],unit:/\(([^)]+)\)/.exec(a[0][r])[1],concentration:parseFloat(a[e][r])});s.push(t)}}else{l=new w({nbRows:"H",nbColumns:12});for(let e=1;e<a.length;e++){const t={id:`1-${a[e][0].concat(a[e][1])}`,reagents:[]};for(let r=2;r<a[0].length;r++)t.reagents.push({label:a[0][r].split("(")[0],unit:/\(([^)]+)\)/.exec(a[0][r])[1],concentration:parseFloat(a[e][r])});s.push(t)}}for(let e=0;e<s.length;e++){l.getWell({id:s[e].id}).updateReagents(s[e].reagents)}return l.updateSamples(),l}}function b(e,t={}){const{columns:r=10}=t,a=Math.floor((e-1)/r);return[a+1,e-r*a]}w.prototype.resurrect=function(){const e=require("src/main/datas").DataObject;let t=Object.keys(this.wells[0]);for(let r of this.wells)for(let a of t)r[a]=e.resurrect(r[a]);this.updateSamples(),t=Object.keys(this.samples[0]);for(let r of this.samples)for(let a of t)r[a]=e.resurrect(r[a])},w.prototype.updateSamples=function(){if(this.samples.length){const e=this.samples;for(let t of e){const e=t.wells.filter((e=>e.inAverage)).map((e=>e.id)),r=this.getWells({ids:e}),a=r.map((e=>e.spectrum.data)),s=r.map((e=>e.growthCurve.data));t.analysis={raw:g(r),averaged:d(r),wells:r.map((e=>({id:e.id,analysis:e.analysis})))},t.averagedSpectra=p(a),t.averagedGrowthCurves=p(s),t.reagents=r[0].reagents,this.test(t)}}else{const e=function(e){let t=[],r=[];for(let a=0;a<e.length;a++){let s=JSON.stringify(e[a].reagents.map((e=>e.concentration)));if(t.find((e=>e===s))+1)continue;t.push(s);const l=e.filter((e=>JSON.stringify(e.reagents.map((e=>e.concentration)))===s)).map((e=>e.id));r.push(l)}return r}(this.wells);let t=[];for(let r of e){const e=r.map((e=>e.split("-")[1])).join("-"),a=r.map((e=>({id:e,inAverage:!0})));t.push(new c({id:h(),label:e,wells:a,metadata:{color:"blue",display:!0,category:null,group:null},results:{},_highlight:r}))}this.samples=t}},w.prototype.test=function(e){const t=e.wells,r=t.filter((e=>e.inAverage)).map((e=>e.id)),a=this.getWells({ids:r}),s=Object.keys(a[0].analysis.processed);if(a.length&&s.length){t.map((e=>e.test=[]));for(const l of s){const s=a.map((e=>e.analysis.processed[l])),{test:n,criticalValue:o}=i(s);e.grubbsCriticalValue=o;for(let e=0;e<t.length;e++)if(r.includes(t[e].id)){const a=r.indexOf(t[e].id);t[e].test.push({label:l,color:n[a].pass?"#46FF8F":"#FF4649",...n[a]})}else{const r=this.getWell({id:t[e].id});t[e].test.push({label:l,color:"#EAEAEA",value:r.analysis.processed[l],score:0,pass:void 0})}}}},e.WellPlateData=w,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=well-plate-data.min.js.map
