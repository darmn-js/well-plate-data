!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).wellPlateData={})}(this,(function(e){"use strict";function t(e={}){let{nbRows:t="h",nbColumns:r="12",nbPlates:s=1,initPlate:l=0,accountPreviousWells:a=!1,direction:i="horizontal"}=e,n=Object.entries({rows:t,columns:r});for(let e=0;e<n.length;e++)if(Number.isNaN(parseInt(n[e][1],10))){let t=n[e][1].toUpperCase().charCodeAt(0),r=new Array(t-64).fill().map(((e,t)=>String.fromCharCode(t+65)));n[e][1]=r}else{let t=new Array(parseInt(n[e][1],10)).fill().map(((e,t)=>t+1));n[e][1]=t}let h=[],[o,u]=[n[0][1],n[1][1]];if(Number.isInteger(o[0])&&Number.isInteger(u[0])){let e="vertical"===i?o:u;for(let t=l;t<l+s;t++)for(let r=0;r<o.length;r++){let s=[];for(let l=0;l<u.length;l++){let[n,h]="vertical"===i?[r,l]:[l,r],g=a?t*o.length*u.length:0;s[l]=`${t+1}-${g+(h*e.length+e[n])}`}h.push(...s)}}else for(let e=l;e<l+s;e++)for(let t=0;t<o.length;t++){let r=[];for(let s=0;s<u.length;s++){let l="string"==typeof o[t]?o[t]+u[s]:u[s]+o[t];r[s]=`${e+1}-${l}`}h.push(...r)}return{labelsList:h,axis:n}}function r(e={}){const{length:t=25}=e;let r=[],s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",l=s.length;for(let e=0;e<t;e++)r.push(s.charAt(Math.floor(Math.random()*l)));return r.join("")}class s{constructor(e={}){let{id:t=r(),label:s,plate:l,metadata:a={},reagents:i=[],results:n=[],_highlight:h=r()}=e;this.id=t,this.selected=!1,this.label=s,this.plate=l,this.results=n,this.metadata=a,this.reagents=i,this.growthCurve={},this.spectrum={},this.growthCurve.x=[],this.growthCurve.y=[],this.spectrum.x=[],this.spectrum.y=[],this._highlight=h}getGrowthCurve(){return this.growthCurve}getSpectrum(){return this.spectrum}getMetadata(){return this.metadata}getReagents(){return this.reagents}getLabel(){return this.label}getID(){return this.id}addGrowthCurve(e){if(!Array.isArray(e.x)||!Array.isArray(e.y))throw new Error("X and Y must be arrays");this.growthCurve=e}addSpectrum(e){if(!Array.isArray(e.x)||!Array.isArray(e.y))throw new Error("X and Y must be arrays");this.spectrum=e}addReagents(e){if(!Array.isArray(e))throw new Error("Reagents must be a vector of objects");if(0===this.reagents.length)this.reagents=e;else{let t=[];for(let r=0;r<e.length;r++){let s=this.reagents[r]?this.reagents[r]:{};t.push(Object.assign({},s,e[r]))}this.reagents=t}}updateReagents(e){if(!Array.isArray(e))throw new Error("Reagents must be a vector of objects");let t=[];for(let r of e){let e=this.reagents.filter((e=>e.label===r.label))[0];t.push(Object.assign({},e,r))}this.reagents=t}addResults(e){if(Array.isArray(e)||"object"!=typeof e)throw new Error("Result must be a object");if(!e.name||!e.value)throw new Error("The name or the value of the result is not defined");this.results.push(e)}}e.WellPlateData=class{constructor(e={}){this.wells=[];const r=t(e).labelsList;this.plateLabels=r;for(let e=0;e<r.length;e++){const t=r[e].split("-");this.wells.push(new s({id:r[e],plate:t[0],label:t[1],_highlight:e}))}}fillPlateFromArray(e){let t=[];for(let r of e)t.push(new s(r));this.wells=t}addReagentsFromArray(e){if(!Array.isArray(e)||this.wells.length!==e.length)throw new Error("Input array must have the same length as wells in the plate");for(let t=0;t<this.wells.length;t++)this.wells[t].addReagents(e[t])}addSpectrumFromArray(e){if(!Array.isArray(e)||this.wells.length!==e.length)throw new Error("Input array must have the same length as wells in the plate");if(!Array.isArray(e)||!Array.isArray(e[0].x)||!Array.isArray(e[0].y))throw new Error("The input array must be an array of objects with x and y components");for(let t=0;t<this.wells.length;t++)this.wells[t].addSpectrum(e[t])}addGrowthCurvesFromArray(e){if(!Array.isArray(e)||this.wells.length!==e.length)throw new Error("The input array must have the same length as wells in the plate");if(!Array.isArray(e)||!Array.isArray(e[0].x)||!Array.isArray(e[0].y)||e[0].y.length!==e[0].x.length)throw new Error("The input array must be an array of objects with x and y components");for(let t=0;t<this.wells.length;t++)this.wells[t].addGrowthCurve(e[t])}addResultsFromArray(e){if(!Array.isArray(e))throw new Error("The results input is not an array");for(let t=0;t<this.wells.length;t++)this.wells[t].addResults(e[t])}getPlateTemplate(){return this.plateLabels.map(((e,t)=>({index:t,label:e,selected:!1,_highlight:t})))}getSamplesIDs(){const e=this.wells;let t=[],r=[];for(let s=0;s<e.length;s++){let l=JSON.stringify(e[s].reagents.map((e=>e.concentration)));if(t.find((e=>e===l))+1)continue;t.push(l);const a=e.filter((e=>JSON.stringify(e.reagents.map((e=>e.concentration)))===l)).map((e=>e.label));r.push(a)}return r}getWells(e={}){const{ids:t}=e;let r=[];for(let e of this.wells)t&&!t.includes(e.id)||r.push(e);return r}getWell(e={}){const{id:t}=e;for(let e of this.wells)if(t===e.id)return e}},e.generatePlateLabels=t,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=well-plate-data.min.js.map
