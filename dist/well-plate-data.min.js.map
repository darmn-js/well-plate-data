{"version":3,"file":"well-plate-data.min.js","sources":["../node_modules/is-any-array/src/index.js","../node_modules/ml-array-mean/lib-es6/index.js","../node_modules/ml-array-sum/lib-es6/index.js","../node_modules/ml-array-variance/lib-es6/index.js","../node_modules/univariate-tests/lib-esm/grubbs.js","../node_modules/ml-array-standard-deviation/lib-es6/index.js","../src/utilities/getRandomId.js","../src/plateSample.js","../src/utilities/addChartStyle.js","../src/utilities/averageAnalysis.js","../src/utilities/averageArrays.js","../src/utilities/checkReagents.js","../src/utilities/rawAnalysis.js","../src/utilities/sortWells.js","../src/well/well.js","../src/wellPlateData.js","../src/utilities/setTypeOfPlate.js","../src/utilities/generatePlateLabels.js","../src/utilities/getSamplesIDs.js"],"sourcesContent":["const toString = Object.prototype.toString;\n\nexport default function isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n","import sum from 'ml-array-sum';\n\nfunction mean(input) {\n  return sum(input) / input.length;\n}\n\nexport default mean;\n","import isArray from 'is-any-array';\n\nfunction sum(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var sumValue = 0;\n\n  for (var i = 0; i < input.length; i++) {\n    sumValue += input[i];\n  }\n\n  return sumValue;\n}\n\nexport default sum;\n","import isArray from 'is-any-array';\nimport arrayMean from 'ml-array-mean';\n\nfunction variance(values) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(values)) {\n    throw new TypeError('input must be an array');\n  }\n\n  var _options$unbiased = options.unbiased,\n      unbiased = _options$unbiased === void 0 ? true : _options$unbiased,\n      _options$mean = options.mean,\n      mean = _options$mean === void 0 ? arrayMean(values) : _options$mean;\n  var sqrError = 0;\n\n  for (var i = 0; i < values.length; i++) {\n    var x = values[i] - mean;\n    sqrError += x * x;\n  }\n\n  if (unbiased) {\n    return sqrError / (values.length - 1);\n  } else {\n    return sqrError / values.length;\n  }\n}\n\nexport { variance as default };\n","import mean from 'ml-array-mean';\nimport standardDeviation from 'ml-array-standard-deviation';\nimport raw from './data/grubbs.json';\nconst { table, confidence } = raw;\n/**\n * Grubbs\n * @returns the result of testing an array of values\n */\nexport function grubbs(values, options = {}) {\n    const { type = 'alphas', value = 0.05 } = options;\n    const meanValue = mean(values);\n    const std = standardDeviation(values);\n    const test = [];\n    if (values.length < 3) {\n        for (const value of values) {\n            test.push({\n                value,\n                score: 0,\n                pass: undefined,\n            });\n        }\n        return { criticalValue: undefined, test };\n    }\n    const criticalValue = table[values.length - 3][confidence[type].indexOf(value)];\n    for (const value of values) {\n        const score = Math.abs(value - meanValue) / std;\n        test.push({\n            value,\n            score,\n            pass: score > criticalValue ? false : true,\n        });\n    }\n    return { criticalValue, test };\n}\n//# sourceMappingURL=grubbs.js.map","import variance from 'ml-array-variance';\n\nfunction standardDeviation(values) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Math.sqrt(variance(values, options));\n}\n\nexport { standardDeviation as default };\n","export function getRandomId(options = {}) {\n  const { length = 25 } = options;\n  let result = [];\n  let characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result.push(\n      characters.charAt(Math.floor(Math.random() * charactersLength)),\n    );\n  }\n  return result.join('');\n}\n","import { getRandomId } from './utilities/getRandomId';\n\nexport class PlateSample {\n  /**\n   * @param {String} id - Identificator\n   * @param {String} label - Sample label\n   * @param {Array}  [wells=[]] - Wells that corresponds to the sample\n   * @param {Object} [metadata={}] - Metadata relate to the well\n   */\n  constructor(options = {}) {\n    let {\n      id = getRandomId(),\n      label = undefined,\n      wells = [],\n      metadata = {\n        color: 'blue',\n        display: true,\n        category: null,\n        group: null,\n      },\n      averagedSpectra = { x: [], y: [] },\n      averagedGrowthCurves = { x: [], y: [] },\n      _highlight = getRandomId(),\n      analysis = {\n        raw: {},\n        averaged: [],\n        wells: [],\n      },\n      results = {},\n      reagents = [],\n    } = options;\n    this.id = id;\n    this.label = label;\n    this.wells = wells;\n    this.metadata = metadata;\n    this.results = results;\n    this.analysis = analysis;\n    this.reagents = reagents;\n    this.averagedSpectra = averagedSpectra;\n    this.averagedGrowthCurves = averagedGrowthCurves;\n    this._highlight = _highlight;\n  }\n}\n\n","\nexport function addChartStyle(data, well) {\n    data.styles = {\n      unselected: {\n        lineColor: well.metadata.color || 'red',\n        lineWidth: 1,\n        lineStyle: 1,\n      },\n      selected: {\n        lineColor: well.metadata.color || 'red',\n        lineWidth: 3,\n        lineStyle: 1,\n      },\n    };\n    data.label = well.id;\n  }","export function averageAnalysis(wells){\n    const keys = Object.keys(wells[0].analysis.processed)\n    let result = [];\n    for (let key of keys) {\n        let average = 0;\n        for (let well of wells) {\n            average += well.analysis.processed[key];\n        }\n        result.push({\n            label: key,\n            value: average / wells.length,\n        })\n    }\n    return result;\n}","export function averageArrays(arrays) {\n  const data = [];\n  for (let array of arrays) {\n    if (array.x && array.y && array.y.length) data.push(array);\n  }\n  if (!data.length) return { x: [], y: [] };\n  let result = [];\n  let xAxis = data[0].x;\n  for (let i = 0; i < data[0].y.length; i++) {\n    let variable = 0;\n    for (let j = 0; j < data.length; j++) {\n      if (data[j].y.length) variable += data[j].y[i];\n    }\n    result.push(variable / data.length);\n  }\n  return {\n    x: xAxis,\n    y: result,\n  };\n}\n","export function checkReagents(well, options={}) {\n  const {\n    checkKeys = true,\n    checkValues = true,\n    keys = ['reference', 'batch', 'uuid', 'concentration']\n  } = options;\n  const reagents = well.reagents;\n  if (reagents.length === 0) throw new Error(`The well ${well.id} has no reagents`);\n  for (let reagent of reagents) {\n    const entries = Object.entries(reagent);\n    if (checkKeys) {\n      const inputKeys = entries.map((item) => item[0]);\n      for (let i = 0; i < keys.length; i++) {\n        const boolean = inputKeys.find((item) => item === keys[i]);\n        if (!boolean) {\n          throw new Error(\n            `Property ${keys[i].toUpperCase()} not defined for ${reagent.label} at ${well.id}`,\n          );\n        }\n      }\n    }\n\n    if (checkValues) {\n      const inputValues = entries.map((item) => item[1]);\n      for (let i = 0; i < keys.length; i++) {\n        const index = inputValues.findIndex(\n          (item) => item === null || item === undefined || item === '',\n        );\n        if (index !== -1) {\n          throw new Error(\n            `Property ${entries[index][0].toUpperCase()} has undefined value for ${reagent.label} at ${well.id}`,\n          );\n        }\n      }\n    }\n  }\n}\n","export function rawAnalysis(wells){\n    const keys = Object.keys(wells[0].analysis.processed)\n    let result = {};\n    for (let key of keys) {\n        let average = 0;\n        for (let well of wells) {\n            average += well.analysis.processed[key];\n        }\n        result[key] = average / wells.length\n    }\n    return result;\n}\n","/**\n * Returns the array of wells sorted regarding its alphanumeric identifier.\n * @param {Array} - Array of wells\n * @returns {Array}\n */\nexport function sortWells(array, options={}) {\n    const { path = 'id' } = options;\n    return array.sort((a, b) => {\n        return a[path].localeCompare(b[path], 'en', { numeric: true });\n    })\n}","import { getRandomId } from '../utilities/getRandomId';\n\nexport class Well {\n  /**\n   * @param {String} id - Identificator\n   * @param {String} label - Well label\n   * @param {Number} plate - Number of the plate\n   * @param {Object} [data={}] - Spectrum and growth curves data\n   * @param {Object} [data.growthCurve={}]  - Growth curve obtaineed\n   * @param {Array}  [data.growthCurve.x=[]]\n   * @param {Array} [data.growthCurve.y=[]]\n   * @param {Object} [data.spectrum={}]\n   * @param {Array} [data.spectrum.x=[]] - Spectrum obtaineed\n   * @param {Array} [data.spectrum.y=[]]\n   * @param {Object} [options={}]\n   * @param {Object} [options.metadata={}] - Metadata relate to the well\n   * @param {Object} [options.analysis={}] - Metadata relate to the well\n   * @param {Array} [options.reagents=[]] - Rctants used in the well\n   */\n  constructor(options = {}) {\n    let {\n      id = getRandomId(),\n      label = undefined,\n      plate,\n      metadata = {\n        color: 'black',\n        display: true,\n        category: null,\n        group: null,\n      },\n      reagents = [],\n      analysis = {\n        raw: {},\n        processed: {}\n      },\n      growthCurve = {\n        data: { x: [], y: [] }\n      },\n      spectrum = {\n        data: { x: [], y: [] }\n      }\n    } = options;\n\n    this.id = id;\n    this.selected = false;\n    this.label = label;\n    this.plate = plate;\n    this.analysis = analysis;\n    this.metadata = metadata;\n    this.reagents = reagents;\n    this.growthCurve = growthCurve;\n    this.spectrum = spectrum;\n\n    if (!growthCurve.data.x && !growthCurve.data.y) {\n      this.growthCurve.data.x = [];\n      this.growthCurve.data.y = [];\n    }\n\n    if (!spectrum.data.x && !spectrum.data.y) {\n      this.spectrum.data.x = [];\n      this.spectrum.data.y = [];\n    }\n\n    this._highlight = id;\n  }\n\n  /**\n   * Returns the growth curve\n   * @returns {Array}\n   */\n  getGrowthCurve() {\n    return this.growthCurve;\n  }\n\n  /**\n   * Returns the spectrum\n   * @returns {Array}\n   */\n  getSpectrum() {\n    return this.spectrum;\n  }\n\n  /**\n   * Returns the metadata of the well\n   * @returns {Object}\n   */\n  getMetadata() {\n    return this.metadata;\n  }\n\n  /**\n   * Returns the reagents presents in the well\n   * @returns {Object}\n   */\n  getReagents() {\n    return this.reagents;\n  }\n\n  /**\n   * Returns the label of the well\n   * @returns {Object}\n   */\n  getLabel() {\n    return this.label;\n  }\n\n  /**\n   * Returns the id of the well\n   * @returns {Object}\n   */\n  getID() {\n    return this.id;\n  }\n\n  /**\n   * Set the growth curve obtained from the well\n   * @param {Object} input\n   * @param {Array} [input.x=[]]\n   * @param {Array} [input.y=[]]\n   */\n\n  addGrowthCurve(growthCurve) {\n    if (!Array.isArray(growthCurve.x) || !Array.isArray(growthCurve.y)) {\n      throw new Error(`X and Y must be arrays`);\n    }\n    this.growthCurve = {\n      data: growthCurve\n    };\n  }\n\n  /**\n   * Set the spectrum obtained from the well\n   * @param {Object} input\n   * @param {Array} [input.x=[]]\n   * @param {Array} [input.y=[]]\n   */\n  addSpectrum(spectrum) {\n    if (!Array.isArray(spectrum.x) || !Array.isArray(spectrum.y)) {\n      throw new Error(`X and Y must be arrays`);\n    }\n    this.spectrum = {\n      data: spectrum\n    };\n  }\n\n  /**\n   * Sets the reagents constituent of the well\n   * @param {Object} reagents - Array of reagents as objects\n   */\n  addReagents(reagents) {\n    if (!Array.isArray(reagents)) {\n      throw new Error(`Reagents must be a vector of objects`);\n    }\n    if (this.reagents.length === 0) {\n      this.reagents = reagents;\n    } else {\n      let newReagents = [];\n      for (let i = 0; i < reagents.length; i++) {\n        let previousReagents = this.reagents[i] ? this.reagents[i] : {};\n        newReagents.push(Object.assign({}, previousReagents, reagents[i]));\n      }\n      this.reagents = newReagents;\n    }\n  }\n\n  /**\n   * Sets the reagents constituent of the well\n   * @param {Object} reagents - Array of reagents as objects\n   */\n  updateReagents(reagents) {\n    if (!Array.isArray(reagents)) {\n      throw new Error(`Reagents must be a vector of objects`);\n    }\n    let newReagents = [];\n    for (let reagent of reagents) {\n      let previousReagent = this.reagents.filter((item) => item.label === reagent.label)[0];\n      newReagents.push(Object.assign({}, previousReagent, reagent));\n    }\n    this.reagents = newReagents;\n  }\n\n  /**\n   * Adds analysis to the well\n   * @param {Array} analysis - Object containing the analysis\n   */\n  addAnalysis(analysis) {\n    if (Array.isArray(analysis) || typeof analysis !== 'object') {\n      throw new Error(`Result must be a object`);\n    }\n    let { name, value } = analysis;\n    this.analysis.raw[name] = value;\n    this.analysis.processed[name] = value;\n  }\n}\n","/* eslint-disable prefer-named-capture-group */\n/* eslint-disable func-names */\nimport * as tests from 'univariate-tests';\n\nimport { PlateSample } from './plateSample';\nimport { addChartStyle } from './utilities/addChartStyle';\nimport { averageAnalysis} from './utilities/averageAnalysis';\nimport { averageArrays } from './utilities/averageArrays';\nimport { checkReagents } from './utilities/checkReagents';\nimport { generatePlateLabels } from './utilities/generatePlateLabels';\nimport { getRandomId } from './utilities/getRandomId';\nimport { getSamplesIDs } from './utilities/getSamplesIDs';\nimport { rawAnalysis } from './utilities/rawAnalysis';\nimport { setTypeOfPlate } from './utilities/setTypeOfPlate';\nimport { sortWells } from './utilities/sortWells';\nimport { Well } from './well/well';\n\nexport class WellPlateData {\n  /**\n   * Manager of the data regarding a well plates\n   * @param {Object} [options={}]\n   * @param {String} [options.nbRows] - Indicates the number of rows that the well plate will contain (if the input is a letter the number of rows will increase alphabetically until it reaches the letter defined as input).\n   * @param {String} [options.nbColumns] - Indicates the number of columns that the well plate will contain (if the input is a letter the number of rows will increase alphabetically until it reaches the letter defined as input).\n   * @param {Number} [options.nbPlates] - Indicates the number of plates to be generated.\n   * @param {Number} [options.initPlate] - It referes the plate where the experiment began.\n   * @param {Boolean} [options.accountPreviousWells] - For plates where the well label is a number, this option allows to take in count previous labels in the next plate.\n   * @param {String} [options.direction] - For plates where the well label is a number, this option sets the direction in which this will increase.\n   */\n  constructor(options = {}) {\n    this.wells = [];\n    this.samples = [];\n    this.typeOfPlate = setTypeOfPlate(options);\n    let plateLabels = generatePlateLabels(options);\n    const labelsList = plateLabels.labelsList;\n    for (let i = 0; i < labelsList.length; i++) {\n      const label = labelsList[i].split('-');\n      this.wells.push(\n        new Well({\n          id: labelsList[i],\n          plate: label[0],\n          label: label[1],\n          _highlight: i,\n        }),\n      );\n    }\n  }\n\n  /**\n   * Sets the reagents constituent to each well\n   * @param {Array} reagents - Array containing an array of reagents as objects\n   */\n  addReagentsFromArray(reagents) {\n    if (!Array.isArray(reagents) || this.wells.length !== reagents.length) {\n      throw new Error(\n        `Input array must have the same length as wells in the plate`,\n      );\n    }\n    for (let i = 0; i < this.wells.length; i++) {\n      this.wells[i].addReagents(reagents[i]);\n    }\n    this.updateSamples();\n  }\n\n  /**\n   * Sets the corresponding spectrum to each well\n   * @param {Array} spectra - Array of objects containing the x and y components of the spectrum\n   */\n  addSpectrumFromArray(spectra) {\n    if (!Array.isArray(spectra)) {\n      throw new Error(\n        `Input array must have the same length as wells in the plate`,\n      );\n    }\n    if (\n      !Array.isArray(spectra) ||\n      !Array.isArray(spectra[0].array.x) ||\n      !Array.isArray(spectra[0].array.y) ||\n      spectra[0].array.y.length !== spectra[0].array.x.length\n    ) {\n      throw new Error(`The input array must be an array`);\n    }\n    for (let well of this.wells) {\n      const spectrum = spectra.filter((item) => item.label === well.label)[0];\n      if (spectrum !== undefined) {\n        well.metadata.display = false;\n        well.metadata.color = 'black';\n        well.addSpectrum(spectrum.array);\n      } else {\n        well.metadata.display = false;\n        well.metadata.color = 'darkgrey';\n      }\n    }\n    this.updateSamples();\n  }\n\n  /**\n   * Sets the corresponding growth curve to each well\n   * @param {Array} growthCurves - Array of objects containing the x and y components of the growth curve\n   */\n  addGrowthCurvesFromArray(growthCurves) {\n    if (!Array.isArray(growthCurves)) {\n      throw new Error(`The input array must be an array`);\n    }\n\n    if (\n      !Array.isArray(growthCurves) ||\n      !Array.isArray(growthCurves[0].array.x) ||\n      !Array.isArray(growthCurves[0].array.y) ||\n      growthCurves[0].array.y.length !== growthCurves[0].array.x.length\n    ) {\n      throw new Error(\n        `The input array must be an array of objects with x and y components`,\n      );\n    }\n    for (let well of this.wells) {\n      const growthCurve = growthCurves.filter(\n        (item) => item.label === well.label,\n      )[0];\n      if (growthCurve !== undefined) {\n        well.metadata.display = false;\n        well.metadata.color = 'black';\n        well.addGrowthCurve(growthCurve.array);\n      } else {\n        well.metadata.display = false;\n        well.metadata.color = 'darkgrey';\n      }\n    }\n    this.updateSamples();\n  }\n\n  /**\n   * Sets the corresponding result to each well\n   * @param {Array} analysis - Array of objects containing the analysis added\n   */\n  addAnalysisFromArray(analysis) {\n    if (!Array.isArray(analysis)) {\n      throw new Error('The analysis input is not an array');\n    }\n    for (let i = 0; i < this.wells.length; i++) {\n      this.wells[i].addAnalysis(analysis[i]);\n    }\n  }\n\n  /**\n   * Returns an array of objects with the corresponding labels to each well\n   * @returns {Array}\n   */\n  getWells(options = {}) {\n    const { ids } = options;\n    let wells = [];\n    for (let well of this.wells) {\n      if (!ids || ids.includes(well.id)) wells.push(well);\n    }\n    return wells;\n  }\n\n  /**\n   * Returns an array of objects with the corresponding labels to each well\n   * @returns {Array}\n   */\n  getWell(options = {}) {\n    const { id } = options;\n    for (let well of this.wells) {\n      if (id === well.id) {\n        return well;\n      }\n    }\n  }\n\n  /**\n   * Returns a string with CSV format\n   * @returns {String}\n   */\n  getTemplate(options = {}) {\n    const { separator = ',' } = options;\n    const plate = this.wells;\n    const regex = /(?:[0-9]+)|(?:[a-zA-Z]+)/g;\n    const reagentsLabels = plate[0].reagents.map((item) => (item.label));\n    const reagentsUnits = plate[0].reagents.map((item) => (item.unit));\n    const reagents = [];\n    for (let i = 0; i < reagentsLabels.length; i++) {\n      reagents.push(`${reagentsLabels[i]}(${reagentsUnits[i]})`)\n    }\n\n    const header = ['row', 'column'].concat(reagents);\n    const list = [header];\n    for (let well of plate) {\n      const splittedLabel = Number.isNaN(parseInt(well.label, 10)) ?\n        well.label.match(regex): getWellsPositions(well.label);\n      const concentrations = well.reagents.map((item) => item.concentration);\n      list.push(splittedLabel.concat(concentrations));\n    }\n    return list.map((well) => well.join(separator)).join('\\n');\n  }\n\n  /**\n   * Checks out if the reagents contain the needed information\n   * @param {Object} [options={}]\n   * @param {Boolean} [options.checkKeys] - Parameter that allows to check the keys of the reagents object\n   * @param {Boolean} [options.checkValues] - Parameter that allows to check that the values are defined\n   * @param {Array} [options.keys] - Array of keys to check\n   */\n\n  checkReagents(options = {}) {\n    const wells = this.wells;\n    for (let well of wells) {\n      checkReagents(well, options);\n    }\n  }\n\n  /**\n   * Checks out if the reagents contain the needed information\n   * @param {Object} [options={}]\n   * @param {Boolean} [options.checkKeys] - Parameter that allows to check the keys of the reagents object\n   * @param {Boolean} [options.checkValues] - Parameter that allows to check that the values are defined\n   * @param {Array} [options.keys] - Array of keys to check\n   */\n\n  getSpectraChart(options = {}) {\n    const { ids } = options;\n    const wells = this.wells;\n    let chart = {\n      data: [],\n    };\n\n    for (let well of wells) {\n      if (!ids || ids.includes(well.id)) {\n        if (well.spectrum.data.x.length && well.spectrum.data.y.length) {\n          const data = well.spectrum.data;\n          addChartStyle(data, well);\n          chart.data.push(data);\n        }\n      }\n    }\n    return chart;\n  }\n\n  /**\n   * Checks out if the reagents contain the needed information\n   * @param {Object} [options={}]\n   * @param {Boolean} [options.checkKeys] - Parameter that allows to check the keys of the reagents object\n   * @param {Boolean} [options.checkValues] - Parameter that allows to check that the values are defined\n   * @param {Array} [options.keys] - Array of keys to check\n   */\n\n  getGrowthCurveChart(options = {}) {\n    const { ids } = options;\n    const wells = this.wells;\n    let chart = {\n      data: [],\n    };\n\n    for (let well of wells) {\n      if (!ids || ids.includes(well.id)) {\n        if (well.growthCurve.data.x.length && well.growthCurve.data.y.length) {\n          const data = well.growthCurve.data;\n          addChartStyle(data, well);\n          chart.data.push(data);\n        }\n      }\n    }\n    return chart;\n  }\n\n  getChartOfSpectraSamples(options) {\n    let chart = {\n      data: [],\n    };\n\n    let samples = this.getSamples(options);\n    for (let sample of samples) {\n      const data = sample.averagedSpectra;\n      addChartStyle(data, sample);\n      chart.data.push(data);\n    }\n    return chart;\n  }\n\n  getChartOfGrowthCurvesSamples(options) {\n    let chart = {\n      data: [],\n    };\n\n    let samples = this.getSamples(options);\n    for (let sample of samples) {\n      const data = sample.averagedGrowthCurves;\n      addChartStyle(data, sample);\n      chart.data.push(data);\n    }\n    return chart;\n  }\n\n  /**\n   * Returns an array of objects with the corresponding labels to each well\n   * @returns {Array}\n   */\n  getSamples(options = {}) {\n    const { ids } = options;\n    let samples = [];\n\n    for (let sample of this.samples) {\n      if (!ids || ids.includes(sample.id)) samples.push(sample);\n    }\n    return samples;\n  }\n  /**\n   * Returns an array of objects with the corresponding labels to each well\n   * @returns {Array}\n   */\n  getSample(options = {}) {\n    const { id } = options;\n\n    for (let sample of this.samples) {\n      if (id === sample.id) return sample;\n    }\n  }\n\n  /**\n   * Fills the plate with information coming from external array.\n   * @param {Array} plate - Array containing well data as objects.\n   */\n  static fillPlateFromArray(wells) {\n    wells = sortWells(wells);\n    const lastLabel = sortWells(wells, { path: 'label' })[wells.length - 1].label;\n    let [nbRows, nbColumns] = Number.isNaN(parseInt(lastLabel, 10)) ?\n      lastLabel.match(/[^\\d]+|\\d+/g): [10, 10];\n    const nbPlates = parseInt(wells[wells.length - 1].id.split('-')[0], 10);\n    const wellPlateData = new WellPlateData({ nbRows, nbColumns, nbPlates });\n    for (let well of wells) {\n      const wellIndex = wellPlateData.wells.findIndex((item) => item.id === well.id);\n      wellPlateData.wells[wellIndex] = new Well(well);\n    }\n    wellPlateData.typeOfPlate = `${nbRows}x${nbColumns}`;\n    wellPlateData.updateSamples();\n    return wellPlateData;\n  }\n\n  /**\n   * Create WellPlateData from CSV and TSV files\n   * @param {string} text\n   * @param {object} [options={}]\n   * @param {object} [options.separator=',']\n   */\n  static readTemplate(string, options = {}) {\n    const { separator = ',' } = options;\n    const list = string.split('\\n')\n      .map((row) => row.split(separator))\n      .filter((item) => item !== '');\n    const wells = [];\n    let wellPlateData;\n    if (\n        Number.isInteger(parseInt(list[1][0], 10)) &&\n        Number.isInteger(parseInt(list[1][1], 10))\n    ) {\n      wellPlateData = new WellPlateData({ nbRows: 10, nbColumns: 10 });\n      for (let i = 1; i < list.length; i++) {\n        const well = {\n          id: `1-${((parseInt(list[i][0], 10) - 1) * 10) + parseInt(list[i][1], 10)}`,\n          reagents: [],\n        };\n        for (let j = 2; j < list[0].length; j++) {\n          well.reagents.push({\n            label: list[0][j].split('(')[0],\n            unit: /\\(([^)]+)\\)/.exec(list[0][j])[1],\n            concentration: parseFloat(list[i][j]),\n          });\n        }\n        wells.push(well);\n      }\n    } else {\n      wellPlateData = new WellPlateData({ nbRows: 'H', nbColumns: 12 });\n      for (let i = 1; i < list.length; i++) {\n        const well = {\n          id: `1-${list[i][0].concat(list[i][1])}`,\n          reagents: [],\n        };\n        for (let j = 2; j < list[0].length; j++) {\n          well.reagents.push({\n            label: list[0][j].split('(')[0],\n            unit: /\\(([^)]+)\\)/.exec(list[0][j])[1],\n            concentration: parseFloat(list[i][j]),\n          });\n        }\n        wells.push(well);\n      }\n    }\n    for (let i = 0; i < wells.length; i++) {\n      const selectedWell = wellPlateData.getWell({ id: wells[i].id });\n      selectedWell.updateReagents(wells[i].reagents);\n    }\n    wellPlateData.updateSamples();\n    return wellPlateData;\n  }\n}\n\nWellPlateData.prototype.resurrect = function () {\n  // eslint-disable-next-line import/no-unresolved\n  const Datas = require('src/main/datas')\n  const DataObject = Datas.DataObject;\n  let keys = Object.keys(this.wells[0]);\n  for (let well of this.wells) {\n    for (let key of keys) {\n      well[key] = DataObject.resurrect(well[key]);\n    }\n  }\n  this.updateSamples();\n  keys = Object.keys(this.samples[0]);\n  for (let sample of this.samples){\n    for (let key of keys){\n      sample[key] = DataObject.resurrect(sample[key])\n    }\n  }\n};\n\nWellPlateData.prototype.updateSamples = function () {\n  if (!this.samples.length) {\n    const samplesIDs = getSamplesIDs(this.wells);\n    let samples = [];\n    for (let sampleIDs of samplesIDs) {\n      const label = sampleIDs.map((item) => item.split('-')[1]).join('-');\n      const wells = sampleIDs.map((item) => ({ id: item, inAverage: true }));\n      samples.push(\n        new PlateSample({\n          id: getRandomId(),\n          label: label,\n          wells: wells,\n          metadata: {\n            color: 'blue',\n            display: true,\n            category: null,\n            group: null,\n          },\n          results: {},\n          _highlight: sampleIDs,\n        }),\n      );\n    }\n    this.samples = samples;\n  } else {\n    const samples = this.samples;\n    for (let sample of samples) {\n      const ids = sample.wells.filter((item) => (item.inAverage)).map((item) => (item.id));\n      const wells = this.getWells({ ids });\n      const spectra = wells.map((item) => item.spectrum.data);\n      const growthCurves = wells.map((item) => item.growthCurve.data);\n      sample.analysis = {\n        raw: rawAnalysis(wells),\n        averaged: averageAnalysis(wells),\n        wells: wells.map((well) => ({ id: well.id, analysis: well.analysis }))\n      }\n      sample.averagedSpectra = averageArrays(spectra);\n      sample.averagedGrowthCurves = averageArrays(growthCurves);\n      sample.reagents = wells[0].reagents;\n      this.test(sample);\n    }\n  }\n};\n\nWellPlateData.prototype.test = function(sample){\n  const sampleWells = sample.wells;\n  const ids = sampleWells\n      .filter((item) => item.inAverage)\n      .map((item) => item.id);\n  const wells = this.getWells({ ids });\n  const keys = Object.keys(wells[0].analysis.processed);\n  if (!wells.length || !keys.length) return;\n  sampleWells.map((item) => (item.test = []))\n  for (const key of keys) {\n    const values = wells.map((item) => item.analysis.processed[key]);\n    const { test, criticalValue } = tests.grubbs(values);\n    sample.grubbsCriticalValue = criticalValue;\n    for (let i = 0; i < sampleWells.length; i++) {\n      if (ids.includes(sampleWells[i].id)) {\n        const index = ids.indexOf(sampleWells[i].id)\n        sampleWells[i].test.push({\n          label: key,\n          color: test[index].pass? '#46FF8F': '#FF4649',\n          ...test[index]\n        });\n      } else {\n        const well = this.getWell({ id: sampleWells[i].id })\n        sampleWells[i].test.push({\n          label: key,\n          color: '#EAEAEA',\n          value: well.analysis.processed[key],\n          score: 0,\n          pass: undefined\n        });\n      }\n    }\n  }\n}\n\nfunction getWellsPositions(label, options={}) {\n  const { columns = 10 } = options;\n  const nbRow = Math.floor((label - 1) / columns);\n  const nbColumn = label - (columns * nbRow);\n  return [nbRow + 1, nbColumn]\n}\n","export function setTypeOfPlate(options = {}) {\n  const { nbRows = 'h', nbColumns = '12' } = options;\n  const rows = Number.isNaN(parseInt(nbRows, 10))\n    ? nbRows.toUpperCase()\n    : parseInt(nbRows, 10);\n  const columns = Number.isNaN(parseInt(nbColumns, 10))\n    ? nbColumns.toUpperCase()\n    : parseInt(nbColumns, 10);\n  return `${rows}x${columns}`;\n}\n","/**\n * Returns an array of labels as strings\n * @param {object} [options={}]\n * @param {string} [options.nbRows] - Indicates the number of rows that the well plate will contain (if the input is a letter the number of rows will increase alphabetically until it reaches the letter defined as input).\n * @param {string} [options.nbColumns] - Indicates the number of columns that the well plate will contain (if the input is a letter the number of rows will increase alphabetically until it reaches the letter defined as input).\n * @param {number} [options.nbPlates] - Indicates the number of plates to be generated.\n * @param {number} [options.initPlate] - It referes the plate where the experiment began.\n * @param {boolean} [options.accountPreviousWells] - For plates where the well label is a number, this option allows to take in count previous labels in the next plate.\n * @param {string} [options.direction] - For plates where the well label is a number, this option sets the direction in which this will increase.\n * @return {Object} {labelsList, axis }\n */\n\nexport function generatePlateLabels(options = {}) {\n  let {\n    nbRows = 'h',\n    nbColumns = '12',\n    nbPlates = 1,\n    initPlate = 0,\n    accountPreviousWells = false,\n    direction = 'horizontal',\n  } = options;\n\n  let entries = Object.entries({ rows: nbRows, columns: nbColumns });\n\n  for (let i = 0; i < entries.length; i++) {\n    if (Number.isNaN(parseInt(entries[i][1], 10))) {\n      let label = entries[i][1].toUpperCase().charCodeAt(0);\n      let axis = new Array(label - 64)\n        .fill()\n        .map((item, index) => String.fromCharCode(index + 65));\n      entries[i][1] = axis;\n    } else {\n      let axis = new Array(parseInt(entries[i][1], 10))\n        .fill()\n        .map((item, index) => index + 1);\n      entries[i][1] = axis;\n    }\n  }\n  let labelsList = [];\n  let [rows, columns] = [entries[0][1], entries[1][1]];\n  if (Number.isInteger(rows[0]) && Number.isInteger(columns[0])) {\n    let rod = direction === 'vertical' ? rows : columns;\n    for (let u = initPlate; u < initPlate + nbPlates; u++) {\n      for (let i = 0; i < rows.length; i++) {\n        let row = [];\n        for (let j = 0; j < columns.length; j++) {\n          let [rowIndex, columnIndex] =\n            direction === 'vertical' ? [i, j] : [j, i];\n          let factor = accountPreviousWells\n            ? u * rows.length * columns.length\n            : 0;\n          row[j] = `${u + 1}-${\n            factor + (columnIndex * rod.length + rod[rowIndex])\n          }`;\n        }\n        labelsList.push(...row);\n      }\n    }\n  } else {\n    for (let u = initPlate; u < initPlate + nbPlates; u++) {\n      for (let i = 0; i < rows.length; i++) {\n        let row = [];\n        for (let j = 0; j < columns.length; j++) {\n          let element =\n            typeof rows[i] === 'string'\n              ? rows[i] + columns[j]\n              : columns[j] + rows[i];\n          row[j] = `${u + 1}-${element}`;\n        }\n        labelsList.push(...row);\n      }\n    }\n  }\n  return {\n    labelsList: labelsList,\n    axis: entries,\n  };\n}\n","/**\n * Returns an array of objects containing IDs of the wells with the same reagents and the corresponding key reagents\n * @returns {Array}\n */\nexport function getSamplesIDs(wells) {\n  let sampleWells = [];\n  let sampleIDs = [];\n  for (let i = 0; i < wells.length; i++) {\n    let replicated = JSON.stringify(\n      wells[i].reagents.map((item) => item.concentration),\n    );\n    let feature = sampleWells.find((element) => element === replicated);\n    if (feature + 1) continue;\n    sampleWells.push(replicated);\n    const replicates = wells\n      .filter((item) => JSON.stringify(item.reagents.map((element) => element.concentration)) === replicated)\n      .map((item) => item.id);\n    sampleIDs.push(replicates);\n  }\n  return sampleIDs;\n}\n"],"names":["toString","Object","prototype","isAnyArray","object","call","endsWith","mean","input","isArray","TypeError","length","sumValue","i","sum","variance","values","options","arguments","undefined","_options$unbiased","unbiased","_options$mean","arrayMean","sqrError","x","table","confidence","raw","grubbs","type","value","meanValue","std","Math","sqrt","standardDeviation","test","push","score","pass","criticalValue","indexOf","abs","getRandomId","result","characters","charactersLength","charAt","floor","random","join","PlateSample","constructor","id","label","wells","metadata","color","display","category","group","averagedSpectra","y","averagedGrowthCurves","_highlight","analysis","averaged","results","reagents","addChartStyle","data","well","styles","unselected","lineColor","lineWidth","lineStyle","selected","averageAnalysis","keys","processed","key","average","averageArrays","arrays","array","xAxis","variable","j","checkReagents","checkKeys","checkValues","Error","reagent","entries","inputKeys","map","item","find","toUpperCase","inputValues","index","findIndex","rawAnalysis","sortWells","path","sort","a","b","localeCompare","numeric","Well","plate","growthCurve","spectrum","getGrowthCurve","this","getSpectrum","getMetadata","getReagents","getLabel","getID","addGrowthCurve","Array","addSpectrum","addReagents","newReagents","previousReagents","assign","updateReagents","previousReagent","filter","addAnalysis","name","WellPlateData","samples","typeOfPlate","nbRows","nbColumns","Number","isNaN","parseInt","setTypeOfPlate","labelsList","nbPlates","initPlate","accountPreviousWells","direction","rows","columns","charCodeAt","axis","fill","String","fromCharCode","isInteger","rod","u","row","rowIndex","columnIndex","factor","element","generatePlateLabels","split","addReagentsFromArray","updateSamples","addSpectrumFromArray","spectra","addGrowthCurvesFromArray","growthCurves","addAnalysisFromArray","getWells","ids","includes","getWell","getTemplate","separator","regex","reagentsLabels","reagentsUnits","unit","list","concat","splittedLabel","match","getWellsPositions","concentrations","concentration","getSpectraChart","chart","getGrowthCurveChart","getChartOfSpectraSamples","getSamples","sample","getChartOfGrowthCurvesSamples","getSample","lastLabel","wellPlateData","wellIndex","string","exec","parseFloat","nbRow","resurrect","DataObject","require","inAverage","samplesIDs","sampleWells","sampleIDs","replicated","JSON","stringify","replicates","getSamplesIDs","tests","grubbsCriticalValue"],"mappings":"qPAAA,MAAMA,EAAWC,OAAOC,UAAUF,SAEnB,SAASG,EAAWC,UAC1BJ,EAASK,KAAKD,GAAQE,SAAS,UCDxC,SAASC,EAAKC,UCAd,SAAaA,OACNC,EAAQD,SACL,IAAIE,UAAU,6BAGD,IAAjBF,EAAMG,aACF,IAAID,UAAU,mCAGlBE,EAAW,EAENC,EAAI,EAAGA,EAAIL,EAAMG,OAAQE,IAChCD,GAAYJ,EAAMK,UAGbD,EDdAE,CAAIN,GAASA,EAAMG,OEA5B,SAASI,EAASC,OACZC,EAAUC,UAAUP,OAAS,QAAsBQ,IAAjBD,UAAU,GAAmBA,UAAU,GAAK,OAE7ET,EAAQO,SACL,IAAIN,UAAU,kCAGlBU,EAAoBH,EAAQI,SAC5BA,OAAiC,IAAtBD,GAAsCA,EACjDE,EAAgBL,EAAQV,KACxBA,OAAyB,IAAlBe,EAA2BC,EAAUP,GAAUM,EACtDE,EAAW,EAENX,EAAI,EAAGA,EAAIG,EAAOL,OAAQE,IAAK,KAClCY,EAAIT,EAAOH,GAAKN,EACpBiB,GAAYC,EAAIA,SAGdJ,EACKG,GAAYR,EAAOL,OAAS,GAE5Ba,EAAWR,EAAOL,8uEClB7B,MAAMe,MAAEA,EAAFC,WAASA,GAAeC,EAKxB,SAAUC,EAAOb,EAAkBC,EAAmB,UACpDa,KAAEA,EAAO,SAATC,MAAmBA,EAAQ,KAASd,EACpCe,EAAYzB,EAAKS,GACjBiB,ECZR,SAA2BjB,OACrBC,EAAUC,UAAUP,OAAS,QAAsBQ,IAAjBD,UAAU,GAAmBA,UAAU,GAAK,UAC3EgB,KAAKC,KAAKpB,EAASC,EAAQC,IDUtBmB,CAAkBpB,GACxBqB,EAAO,MACTrB,EAAOL,OAAS,EAAG,KAChB,MAAMoB,KAASf,EAClBqB,EAAKC,KAAK,CACRP,MAAAA,EACAQ,MAAO,EACPC,UAAMrB,UAGH,CAAEsB,mBAAetB,EAAWkB,KAAAA,SAE/BI,EACJf,EAAMV,EAAOL,OAAS,GAAGgB,EAAWG,GAAMY,QAAQX,QAC/C,MAAMA,KAASf,EAAQ,OACpBuB,EAAQL,KAAKS,IAAIZ,EAAQC,GAAaC,EAC5CI,EAAKC,KAAK,CACRP,MAAAA,EACAQ,MAAAA,EACAC,OAAMD,EAAQE,WAGX,CAAEA,cAAAA,EAAeJ,KAAAA,GEpCnB,SAASO,EAAY3B,EAAU,UAC9BN,OAAEA,EAAS,IAAOM,MACpB4B,EAAS,GACTC,EACF,iEACEC,EAAmBD,EAAWnC,WAC7B,IAAIE,EAAI,EAAGA,EAAIF,EAAQE,IAC1BgC,EAAOP,KACLQ,EAAWE,OAAOd,KAAKe,MAAMf,KAAKgB,SAAWH,YAG1CF,EAAOM,KAAK,ICTd,MAAMC,EAOXC,YAAYpC,EAAU,QAChBqC,GACFA,EAAKV,IADHW,MAEFA,EAFEC,MAGFA,EAAQ,GAHNC,SAIFA,EAAW,CACTC,MAAO,OACPC,SAAS,EACTC,SAAU,KACVC,MAAO,MARPC,gBAUFA,EAAkB,CAAErC,EAAG,GAAIsC,EAAG,IAV5BC,qBAWFA,EAAuB,CAAEvC,EAAG,GAAIsC,EAAG,IAXjCE,WAYFA,EAAarB,IAZXsB,SAaFA,EAAW,CACTtC,IAAK,GACLuC,SAAU,GACVX,MAAO,IAhBPY,QAkBFA,EAAU,GAlBRC,SAmBFA,EAAW,IACTpD,OACCqC,GAAKA,OACLC,MAAQA,OACRC,MAAQA,OACRC,SAAWA,OACXW,QAAUA,OACVF,SAAWA,OACXG,SAAWA,OACXP,gBAAkBA,OAClBE,qBAAuBA,OACvBC,WAAaA,GCvCf,SAASK,EAAcC,EAAMC,GAChCD,EAAKE,OAAS,CACZC,WAAY,CACVC,UAAWH,EAAKf,SAASC,OAAS,MAClCkB,UAAW,EACXC,UAAW,GAEbC,SAAU,CACRH,UAAWH,EAAKf,SAASC,OAAS,MAClCkB,UAAW,EACXC,UAAW,IAGfN,EAAKhB,MAAQiB,EAAKlB,GCdf,SAASyB,EAAgBvB,SACtBwB,EAAO/E,OAAO+E,KAAKxB,EAAM,GAAGU,SAASe,eACvCpC,EAAS,OACR,IAAIqC,KAAOF,EAAM,KACdG,EAAU,MACT,IAAIX,KAAQhB,EACb2B,GAAWX,EAAKN,SAASe,UAAUC,GAEvCrC,EAAOP,KAAK,CACRiB,MAAO2B,EACPnD,MAAOoD,EAAU3B,EAAM7C,gBAGxBkC,ECbJ,SAASuC,EAAcC,SACtBd,EAAO,OACR,IAAIe,KAASD,EACZC,EAAM7D,GAAK6D,EAAMvB,GAAKuB,EAAMvB,EAAEpD,QAAQ4D,EAAKjC,KAAKgD,OAEjDf,EAAK5D,OAAQ,MAAO,CAAEc,EAAG,GAAIsC,EAAG,QACjClB,EAAS,GACT0C,EAAQhB,EAAK,GAAG9C,MACf,IAAIZ,EAAI,EAAGA,EAAI0D,EAAK,GAAGR,EAAEpD,OAAQE,IAAK,KACrC2E,EAAW,MACV,IAAIC,EAAI,EAAGA,EAAIlB,EAAK5D,OAAQ8E,IAC3BlB,EAAKkB,GAAG1B,EAAEpD,SAAQ6E,GAAYjB,EAAKkB,GAAG1B,EAAElD,IAE9CgC,EAAOP,KAAKkD,EAAWjB,EAAK5D,cAEvB,CACLc,EAAG8D,EACHxB,EAAGlB,GCjBA,SAAS6C,EAAclB,EAAMvD,EAAQ,UACpC0E,UACJA,GAAY,EADRC,YAEJA,GAAc,EAFVZ,KAGJA,EAAO,CAAC,YAAa,QAAS,OAAQ,kBACpC/D,EACEoD,EAAWG,EAAKH,YACE,IAApBA,EAAS1D,OAAc,MAAM,IAAIkF,MAAO,YAAWrB,EAAKlB,0BACvD,IAAIwC,KAAWzB,EAAU,OACtB0B,EAAU9F,OAAO8F,QAAQD,MAC3BH,EAAW,OACPK,EAAYD,EAAQE,KAAKC,GAASA,EAAK,SACxC,IAAIrF,EAAI,EAAGA,EAAImE,EAAKrE,OAAQE,IAAK,KACpBmF,EAAUG,MAAMD,GAASA,IAASlB,EAAKnE,WAE/C,IAAIgF,MACP,YAAWb,EAAKnE,GAAGuF,iCAAiCN,EAAQvC,YAAYiB,EAAKlB,UAMlFsC,EAAa,OACTS,EAAcN,EAAQE,KAAKC,GAASA,EAAK,SAC1C,IAAIrF,EAAI,EAAGA,EAAImE,EAAKrE,OAAQE,IAAK,OAC9ByF,EAAQD,EAAYE,WACvBL,GAASA,MAAAA,GAAgD,KAATA,QAEpC,IAAXI,QACI,IAAIT,MACP,YAAWE,EAAQO,GAAO,GAAGF,yCAAyCN,EAAQvC,YAAYiB,EAAKlB,SC9BrG,SAASkD,EAAYhD,SAClBwB,EAAO/E,OAAO+E,KAAKxB,EAAM,GAAGU,SAASe,eACvCpC,EAAS,OACR,IAAIqC,KAAOF,EAAM,KACdG,EAAU,MACT,IAAIX,KAAQhB,EACb2B,GAAWX,EAAKN,SAASe,UAAUC,GAEvCrC,EAAOqC,GAAOC,EAAU3B,EAAM7C,cAE3BkC,ECLJ,SAAS4D,EAAUnB,EAAOrE,EAAQ,UAC/ByF,KAAEA,EAAO,MAASzF,SACjBqE,EAAMqB,MAAK,CAACC,EAAGC,IACXD,EAAEF,GAAMI,cAAcD,EAAEH,GAAO,KAAM,CAAEK,SAAS,MCNxD,MAAMC,EAiBX3D,YAAYpC,EAAU,QAChBqC,GACFA,EAAKV,IADHW,MAEFA,EAFE0D,MAGFA,EAHExD,SAIFA,EAAW,CACTC,MAAO,QACPC,SAAS,EACTC,SAAU,KACVC,MAAO,MARPQ,SAUFA,EAAW,GAVTH,SAWFA,EAAW,CACTtC,IAAK,GACLqD,UAAW,IAbXiC,YAeFA,EAAc,CACZ3C,KAAM,CAAE9C,EAAG,GAAIsC,EAAG,KAhBlBoD,SAkBFA,EAAW,CACT5C,KAAM,CAAE9C,EAAG,GAAIsC,EAAG,MAElB9C,OAECqC,GAAKA,OACLwB,UAAW,OACXvB,MAAQA,OACR0D,MAAQA,OACR/C,SAAWA,OACXT,SAAWA,OACXY,SAAWA,OACX6C,YAAcA,OACdC,SAAWA,EAEXD,EAAY3C,KAAK9C,GAAMyF,EAAY3C,KAAKR,SACtCmD,YAAY3C,KAAK9C,EAAI,QACrByF,YAAY3C,KAAKR,EAAI,IAGvBoD,EAAS5C,KAAK9C,GAAM0F,EAAS5C,KAAKR,SAChCoD,SAAS5C,KAAK9C,EAAI,QAClB0F,SAAS5C,KAAKR,EAAI,SAGpBE,WAAaX,EAOpB8D,wBACSC,KAAKH,YAOdI,qBACSD,KAAKF,SAOdI,qBACSF,KAAK5D,SAOd+D,qBACSH,KAAKhD,SAOdoD,kBACSJ,KAAK9D,MAOdmE,eACSL,KAAK/D,GAUdqE,eAAeT,OACRU,MAAMnH,QAAQyG,EAAYzF,KAAOmG,MAAMnH,QAAQyG,EAAYnD,SACxD,IAAI8B,MAAO,+BAEdqB,YAAc,CACjB3C,KAAM2C,GAUVW,YAAYV,OACLS,MAAMnH,QAAQ0G,EAAS1F,KAAOmG,MAAMnH,QAAQ0G,EAASpD,SAClD,IAAI8B,MAAO,+BAEdsB,SAAW,CACd5C,KAAM4C,GAQVW,YAAYzD,OACLuD,MAAMnH,QAAQ4D,SACX,IAAIwB,MAAO,2CAEU,IAAzBwB,KAAKhD,SAAS1D,YACX0D,SAAWA,MACX,KACD0D,EAAc,OACb,IAAIlH,EAAI,EAAGA,EAAIwD,EAAS1D,OAAQE,IAAK,KACpCmH,EAAmBX,KAAKhD,SAASxD,GAAKwG,KAAKhD,SAASxD,GAAK,GAC7DkH,EAAYzF,KAAKrC,OAAOgI,OAAO,GAAID,EAAkB3D,EAASxD,UAE3DwD,SAAW0D,GAQpBG,eAAe7D,OACRuD,MAAMnH,QAAQ4D,SACX,IAAIwB,MAAO,4CAEfkC,EAAc,OACb,IAAIjC,KAAWzB,EAAU,KACxB8D,EAAkBd,KAAKhD,SAAS+D,QAAQlC,GAASA,EAAK3C,QAAUuC,EAAQvC,QAAO,GACnFwE,EAAYzF,KAAKrC,OAAOgI,OAAO,GAAIE,EAAiBrC,SAEjDzB,SAAW0D,EAOlBM,YAAYnE,MACN0D,MAAMnH,QAAQyD,IAAiC,iBAAbA,QAC9B,IAAI2B,MAAO,+BAEfyC,KAAEA,EAAFvG,MAAQA,GAAUmC,OACjBA,SAAStC,IAAI0G,GAAQvG,OACrBmC,SAASe,UAAUqD,GAAQvG,GC9K7B,MAAMwG,EAWXlF,YAAYpC,EAAU,SACfuC,MAAQ,QACRgF,QAAU,QACVC,YC/BF,SAAwBxH,EAAU,UACjCyH,OAAEA,EAAS,IAAXC,UAAgBA,EAAY,MAAS1H,QAOnC,GANK2H,OAAOC,MAAMC,SAASJ,EAAQ,KACvCA,EAAOtC,cACP0C,SAASJ,EAAQ,OACLE,OAAOC,MAAMC,SAASH,EAAW,KAC7CA,EAAUvC,cACV0C,SAASH,EAAW,MDwBHI,CAAe9H,SAE5B+H,EErBH,SAA6B/H,EAAU,QACxCyH,OACFA,EAAS,IADPC,UAEFA,EAAY,KAFVM,SAGFA,EAAW,EAHTC,UAIFA,EAAY,EAJVC,qBAKFA,GAAuB,EALrBC,UAMFA,EAAY,cACVnI,EAEA8E,EAAU9F,OAAO8F,QAAQ,CAAEsD,KAAMX,EAAQY,QAASX,QAEjD,IAAI9H,EAAI,EAAGA,EAAIkF,EAAQpF,OAAQE,OAC9B+H,OAAOC,MAAMC,SAAS/C,EAAQlF,GAAG,GAAI,KAAM,KACzC0C,EAAQwC,EAAQlF,GAAG,GAAGuF,cAAcmD,WAAW,GAC/CC,EAAO,IAAI5B,MAAMrE,EAAQ,IAC1BkG,OACAxD,KAAI,CAACC,EAAMI,IAAUoD,OAAOC,aAAarD,EAAQ,MACpDP,EAAQlF,GAAG,GAAK2I,MACX,KACDA,EAAO,IAAI5B,MAAMkB,SAAS/C,EAAQlF,GAAG,GAAI,KAC1C4I,OACAxD,KAAI,CAACC,EAAMI,IAAUA,EAAQ,IAChCP,EAAQlF,GAAG,GAAK2I,MAGhBR,EAAa,IACZK,EAAMC,GAAW,CAACvD,EAAQ,GAAG,GAAIA,EAAQ,GAAG,OAC7C6C,OAAOgB,UAAUP,EAAK,KAAOT,OAAOgB,UAAUN,EAAQ,IAAK,KACzDO,EAAoB,aAAdT,EAA2BC,EAAOC,MACvC,IAAIQ,EAAIZ,EAAWY,EAAIZ,EAAYD,EAAUa,QAC3C,IAAIjJ,EAAI,EAAGA,EAAIwI,EAAK1I,OAAQE,IAAK,KAChCkJ,EAAM,OACL,IAAItE,EAAI,EAAGA,EAAI6D,EAAQ3I,OAAQ8E,IAAK,KAClCuE,EAAUC,GACC,aAAdb,EAA2B,CAACvI,EAAG4E,GAAK,CAACA,EAAG5E,GACtCqJ,EAASf,EACTW,EAAIT,EAAK1I,OAAS2I,EAAQ3I,OAC1B,EACJoJ,EAAItE,GAAM,GAAEqE,EAAI,KACdI,GAAUD,EAAcJ,EAAIlJ,OAASkJ,EAAIG,MAG7ChB,EAAW1G,QAAQyH,aAIlB,IAAID,EAAIZ,EAAWY,EAAIZ,EAAYD,EAAUa,QAC3C,IAAIjJ,EAAI,EAAGA,EAAIwI,EAAK1I,OAAQE,IAAK,KAChCkJ,EAAM,OACL,IAAItE,EAAI,EAAGA,EAAI6D,EAAQ3I,OAAQ8E,IAAK,KACnC0E,EACiB,iBAAZd,EAAKxI,GACRwI,EAAKxI,GAAKyI,EAAQ7D,GAClB6D,EAAQ7D,GAAK4D,EAAKxI,GACxBkJ,EAAItE,GAAM,GAAEqE,EAAI,KAAKK,IAEvBnB,EAAW1G,QAAQyH,SAIlB,CACLf,WAAYA,EACZQ,KAAMzD,GF3CYqE,CAAoBnJ,GACP+H,eAC1B,IAAInI,EAAI,EAAGA,EAAImI,EAAWrI,OAAQE,IAAK,OACpC0C,EAAQyF,EAAWnI,GAAGwJ,MAAM,UAC7B7G,MAAMlB,KACT,IAAI0E,EAAK,CACP1D,GAAI0F,EAAWnI,GACfoG,MAAO1D,EAAM,GACbA,MAAOA,EAAM,GACbU,WAAYpD,MAUpByJ,qBAAqBjG,OACduD,MAAMnH,QAAQ4D,IAAagD,KAAK7D,MAAM7C,SAAW0D,EAAS1D,aACvD,IAAIkF,MACP,mEAGA,IAAIhF,EAAI,EAAGA,EAAIwG,KAAK7D,MAAM7C,OAAQE,SAChC2C,MAAM3C,GAAGiH,YAAYzD,EAASxD,SAEhC0J,gBAOPC,qBAAqBC,OACd7C,MAAMnH,QAAQgK,SACX,IAAI5E,MACP,mEAIF+B,MAAMnH,QAAQgK,KACd7C,MAAMnH,QAAQgK,EAAQ,GAAGnF,MAAM7D,KAC/BmG,MAAMnH,QAAQgK,EAAQ,GAAGnF,MAAMvB,IAChC0G,EAAQ,GAAGnF,MAAMvB,EAAEpD,SAAW8J,EAAQ,GAAGnF,MAAM7D,EAAEd,aAE3C,IAAIkF,MAAO,wCAEd,IAAIrB,KAAQ6C,KAAK7D,MAAO,OACrB2D,EAAWsD,EAAQrC,QAAQlC,GAASA,EAAK3C,QAAUiB,EAAKjB,QAAO,QACpDpC,IAAbgG,GACF3C,EAAKf,SAASE,SAAU,EACxBa,EAAKf,SAASC,MAAQ,QACtBc,EAAKqD,YAAYV,EAAS7B,SAE1Bd,EAAKf,SAASE,SAAU,EACxBa,EAAKf,SAASC,MAAQ,iBAGrB6G,gBAOPG,yBAAyBC,OAClB/C,MAAMnH,QAAQkK,SACX,IAAI9E,MAAO,wCAIhB+B,MAAMnH,QAAQkK,KACd/C,MAAMnH,QAAQkK,EAAa,GAAGrF,MAAM7D,KACpCmG,MAAMnH,QAAQkK,EAAa,GAAGrF,MAAMvB,IACrC4G,EAAa,GAAGrF,MAAMvB,EAAEpD,SAAWgK,EAAa,GAAGrF,MAAM7D,EAAEd,aAErD,IAAIkF,MACP,2EAGA,IAAIrB,KAAQ6C,KAAK7D,MAAO,OACrB0D,EAAcyD,EAAavC,QAC9BlC,GAASA,EAAK3C,QAAUiB,EAAKjB,QAC9B,QACkBpC,IAAhB+F,GACF1C,EAAKf,SAASE,SAAU,EACxBa,EAAKf,SAASC,MAAQ,QACtBc,EAAKmD,eAAeT,EAAY5B,SAEhCd,EAAKf,SAASE,SAAU,EACxBa,EAAKf,SAASC,MAAQ,iBAGrB6G,gBAOPK,qBAAqB1G,OACd0D,MAAMnH,QAAQyD,SACX,IAAI2B,MAAM,0CAEb,IAAIhF,EAAI,EAAGA,EAAIwG,KAAK7D,MAAM7C,OAAQE,SAChC2C,MAAM3C,GAAGwH,YAAYnE,EAASrD,IAQvCgK,SAAS5J,EAAU,UACX6J,IAAEA,GAAQ7J,MACZuC,EAAQ,OACP,IAAIgB,KAAQ6C,KAAK7D,MACfsH,IAAOA,EAAIC,SAASvG,EAAKlB,KAAKE,EAAMlB,KAAKkC,UAEzChB,EAOTwH,QAAQ/J,EAAU,UACVqC,GAAEA,GAAOrC,MACV,IAAIuD,KAAQ6C,KAAK7D,SAChBF,IAAOkB,EAAKlB,UACPkB,EASbyG,YAAYhK,EAAU,UACdiK,UAAEA,EAAY,KAAQjK,EACtBgG,EAAQI,KAAK7D,MACb2H,EAAQ,4BACRC,EAAiBnE,EAAM,GAAG5C,SAAS4B,KAAKC,GAAUA,EAAK3C,QACvD8H,EAAgBpE,EAAM,GAAG5C,SAAS4B,KAAKC,GAAUA,EAAKoF,OACtDjH,EAAW,OACZ,IAAIxD,EAAI,EAAGA,EAAIuK,EAAezK,OAAQE,IACzCwD,EAAS/B,KAAM,GAAE8I,EAAevK,MAAMwK,EAAcxK,aAIhD0K,EAAO,CADE,CAAC,MAAO,UAAUC,OAAOnH,QAEnC,IAAIG,KAAQyC,EAAO,OAChBwE,EAAgB7C,OAAOC,MAAMC,SAAStE,EAAKjB,MAAO,KACtDiB,EAAKjB,MAAMmI,MAAMP,GAAQQ,EAAkBnH,EAAKjB,OAC5CqI,EAAiBpH,EAAKH,SAAS4B,KAAKC,GAASA,EAAK2F,gBACxDN,EAAKjJ,KAAKmJ,EAAcD,OAAOI,WAE1BL,EAAKtF,KAAKzB,GAASA,EAAKrB,KAAK+H,KAAY/H,KAAK,MAWvDuC,cAAczE,EAAU,UAChBuC,EAAQ6D,KAAK7D,UACd,IAAIgB,KAAQhB,EACfkC,EAAclB,EAAMvD,GAYxB6K,gBAAgB7K,EAAU,UAClB6J,IAAEA,GAAQ7J,EACVuC,EAAQ6D,KAAK7D,UACfuI,EAAQ,CACVxH,KAAM,QAGH,IAAIC,KAAQhB,OACVsH,GAAOA,EAAIC,SAASvG,EAAKlB,MACxBkB,EAAK2C,SAAS5C,KAAK9C,EAAEd,QAAU6D,EAAK2C,SAAS5C,KAAKR,EAAEpD,OAAQ,OACxD4D,EAAOC,EAAK2C,SAAS5C,KAC3BD,EAAcC,EAAMC,GACpBuH,EAAMxH,KAAKjC,KAAKiC,UAIfwH,EAWTC,oBAAoB/K,EAAU,UACtB6J,IAAEA,GAAQ7J,EACVuC,EAAQ6D,KAAK7D,UACfuI,EAAQ,CACVxH,KAAM,QAGH,IAAIC,KAAQhB,OACVsH,GAAOA,EAAIC,SAASvG,EAAKlB,MACxBkB,EAAK0C,YAAY3C,KAAK9C,EAAEd,QAAU6D,EAAK0C,YAAY3C,KAAKR,EAAEpD,OAAQ,OAC9D4D,EAAOC,EAAK0C,YAAY3C,KAC9BD,EAAcC,EAAMC,GACpBuH,EAAMxH,KAAKjC,KAAKiC,UAIfwH,EAGTE,yBAAyBhL,OACnB8K,EAAQ,CACVxH,KAAM,IAGJiE,EAAUnB,KAAK6E,WAAWjL,OACzB,IAAIkL,KAAU3D,EAAS,OACpBjE,EAAO4H,EAAOrI,gBACpBQ,EAAcC,EAAM4H,GACpBJ,EAAMxH,KAAKjC,KAAKiC,UAEXwH,EAGTK,8BAA8BnL,OACxB8K,EAAQ,CACVxH,KAAM,IAGJiE,EAAUnB,KAAK6E,WAAWjL,OACzB,IAAIkL,KAAU3D,EAAS,OACpBjE,EAAO4H,EAAOnI,qBACpBM,EAAcC,EAAM4H,GACpBJ,EAAMxH,KAAKjC,KAAKiC,UAEXwH,EAOTG,WAAWjL,EAAU,UACb6J,IAAEA,GAAQ7J,MACZuH,EAAU,OAET,IAAI2D,KAAU9E,KAAKmB,QACjBsC,IAAOA,EAAIC,SAASoB,EAAO7I,KAAKkF,EAAQlG,KAAK6J,UAE7C3D,EAMT6D,UAAUpL,EAAU,UACZqC,GAAEA,GAAOrC,MAEV,IAAIkL,KAAU9E,KAAKmB,WAClBlF,IAAO6I,EAAO7I,GAAI,OAAO6I,4BAQP3I,GACxBA,EAAQiD,EAAUjD,SACZ8I,EAAY7F,EAAUjD,EAAO,CAAEkD,KAAM,UAAWlD,EAAM7C,OAAS,GAAG4C,UACnEmF,EAAQC,GAAaC,OAAOC,MAAMC,SAASwD,EAAW,KACzDA,EAAUZ,MAAM,eAAgB,CAAC,GAAI,UACjCzC,EAAWH,SAAStF,EAAMA,EAAM7C,OAAS,GAAG2C,GAAG+G,MAAM,KAAK,GAAI,IAC9DkC,EAAgB,IAAIhE,EAAc,CAAEG,OAAAA,EAAQC,UAAAA,EAAWM,SAAAA,QACxD,IAAIzE,KAAQhB,EAAO,OAChBgJ,EAAYD,EAAc/I,MAAM+C,WAAWL,GAASA,EAAK5C,KAAOkB,EAAKlB,KAC3EiJ,EAAc/I,MAAMgJ,GAAa,IAAIxF,EAAKxC,UAE5C+H,EAAc9D,YAAe,GAAEC,KAAUC,IACzC4D,EAAchC,gBACPgC,sBASWE,EAAQxL,EAAU,UAC9BiK,UAAEA,EAAY,KAAQjK,EACtBsK,EAAOkB,EAAOpC,MAAM,MACvBpE,KAAK8D,GAAQA,EAAIM,MAAMa,KACvB9C,QAAQlC,GAAkB,KAATA,IACd1C,EAAQ,OACV+I,KAEA3D,OAAOgB,UAAUd,SAASyC,EAAK,GAAG,GAAI,MACtC3C,OAAOgB,UAAUd,SAASyC,EAAK,GAAG,GAAI,KACxC,CACAgB,EAAgB,IAAIhE,EAAc,CAAEG,OAAQ,GAAIC,UAAW,SACtD,IAAI9H,EAAI,EAAGA,EAAI0K,EAAK5K,OAAQE,IAAK,OAC9B2D,EAAO,CACXlB,GAAK,KAAsC,IAAhCwF,SAASyC,EAAK1K,GAAG,GAAI,IAAM,GAAWiI,SAASyC,EAAK1K,GAAG,GAAI,MACtEwD,SAAU,QAEP,IAAIoB,EAAI,EAAGA,EAAI8F,EAAK,GAAG5K,OAAQ8E,IAClCjB,EAAKH,SAAS/B,KAAK,CACjBiB,MAAOgI,EAAK,GAAG9F,GAAG4E,MAAM,KAAK,GAC7BiB,KAAM,cAAcoB,KAAKnB,EAAK,GAAG9F,IAAI,GACrCoG,cAAec,WAAWpB,EAAK1K,GAAG4E,MAGtCjC,EAAMlB,KAAKkC,QAER,CACL+H,EAAgB,IAAIhE,EAAc,CAAEG,OAAQ,IAAKC,UAAW,SACvD,IAAI9H,EAAI,EAAGA,EAAI0K,EAAK5K,OAAQE,IAAK,OAC9B2D,EAAO,CACXlB,GAAK,KAAIiI,EAAK1K,GAAG,GAAG2K,OAAOD,EAAK1K,GAAG,MACnCwD,SAAU,QAEP,IAAIoB,EAAI,EAAGA,EAAI8F,EAAK,GAAG5K,OAAQ8E,IAClCjB,EAAKH,SAAS/B,KAAK,CACjBiB,MAAOgI,EAAK,GAAG9F,GAAG4E,MAAM,KAAK,GAC7BiB,KAAM,cAAcoB,KAAKnB,EAAK,GAAG9F,IAAI,GACrCoG,cAAec,WAAWpB,EAAK1K,GAAG4E,MAGtCjC,EAAMlB,KAAKkC,QAGV,IAAI3D,EAAI,EAAGA,EAAI2C,EAAM7C,OAAQE,IAAK,CAChB0L,EAAcvB,QAAQ,CAAE1H,GAAIE,EAAM3C,GAAGyC,KAC7C4E,eAAe1E,EAAM3C,GAAGwD,iBAEvCkI,EAAchC,gBACPgC,GAsGX,SAASZ,EAAkBpI,EAAOtC,EAAQ,UAClCqI,QAAEA,EAAU,IAAOrI,EACnB2L,EAAQ1K,KAAKe,OAAOM,EAAQ,GAAK+F,SAEhC,CAACsD,EAAQ,EADCrJ,EAAS+F,EAAUsD,GArGtCrE,EAAcrI,UAAU2M,UAAY,iBAG5BC,EADQC,QAAQ,kBACGD,eACrB9H,EAAO/E,OAAO+E,KAAKqC,KAAK7D,MAAM,QAC7B,IAAIgB,KAAQ6C,KAAK7D,UACf,IAAI0B,KAAOF,EACdR,EAAKU,GAAO4H,EAAWD,UAAUrI,EAAKU,SAGrCqF,gBACLvF,EAAO/E,OAAO+E,KAAKqC,KAAKmB,QAAQ,QAC3B,IAAI2D,KAAU9E,KAAKmB,YACjB,IAAItD,KAAOF,EACdmH,EAAOjH,GAAO4H,EAAWD,UAAUV,EAAOjH,KAKhDqD,EAAcrI,UAAUqK,cAAgB,cACjClD,KAAKmB,QAAQ7H,OAuBX,OACC6H,EAAUnB,KAAKmB,YAChB,IAAI2D,KAAU3D,EAAS,OACpBsC,EAAMqB,EAAO3I,MAAM4E,QAAQlC,GAAUA,EAAK8G,YAAY/G,KAAKC,GAAUA,EAAK5C,KAC1EE,EAAQ6D,KAAKwD,SAAS,CAAEC,IAAAA,IACxBL,EAAUjH,EAAMyC,KAAKC,GAASA,EAAKiB,SAAS5C,OAC5CoG,EAAenH,EAAMyC,KAAKC,GAASA,EAAKgB,YAAY3C,OAC1D4H,EAAOjI,SAAW,CAChBtC,IAAK4E,EAAYhD,GACjBW,SAAUY,EAAgBvB,GAC1BA,MAAOA,EAAMyC,KAAKzB,KAAYlB,GAAIkB,EAAKlB,GAAIY,SAAUM,EAAKN,cAE5DiI,EAAOrI,gBAAkBsB,EAAcqF,GACvC0B,EAAOnI,qBAAuBoB,EAAcuF,GAC5CwB,EAAO9H,SAAWb,EAAM,GAAGa,cACtBhC,KAAK8J,QAtCY,OAClBc,EG5ZH,SAAuBzJ,OACxB0J,EAAc,GACdC,EAAY,OACX,IAAItM,EAAI,EAAGA,EAAI2C,EAAM7C,OAAQE,IAAK,KACjCuM,EAAaC,KAAKC,UACpB9J,EAAM3C,GAAGwD,SAAS4B,KAAKC,GAASA,EAAK2F,oBAEzBqB,EAAY/G,MAAMgE,GAAYA,IAAYiD,IAC1C,EAAG,SACjBF,EAAY5K,KAAK8K,SACXG,EAAa/J,EAChB4E,QAAQlC,GAASmH,KAAKC,UAAUpH,EAAK7B,SAAS4B,KAAKkE,GAAYA,EAAQ0B,mBAAoBuB,IAC3FnH,KAAKC,GAASA,EAAK5C,KACtB6J,EAAU7K,KAAKiL,UAEVJ,EH6YcK,CAAcnG,KAAK7D,WAClCgF,EAAU,OACT,IAAI2E,KAAaF,EAAY,OAC1B1J,EAAQ4J,EAAUlH,KAAKC,GAASA,EAAKmE,MAAM,KAAK,KAAIlH,KAAK,KACzDK,EAAQ2J,EAAUlH,KAAKC,KAAY5C,GAAI4C,EAAM8G,WAAW,MAC9DxE,EAAQlG,KACN,IAAIc,EAAY,CACdE,GAAIV,IACJW,MAAOA,EACPC,MAAOA,EACPC,SAAU,CACRC,MAAO,OACPC,SAAS,EACTC,SAAU,KACVC,MAAO,MAETO,QAAS,GACTH,WAAYkJ,UAIb3E,QAAUA,IAqBnBD,EAAcrI,UAAUmC,KAAO,SAAS8J,SAChCe,EAAcf,EAAO3I,MACrBsH,EAAMoC,EACP9E,QAAQlC,GAASA,EAAK8G,YACtB/G,KAAKC,GAASA,EAAK5C,KAClBE,EAAQ6D,KAAKwD,SAAS,CAAEC,IAAAA,IACxB9F,EAAO/E,OAAO+E,KAAKxB,EAAM,GAAGU,SAASe,cACtCzB,EAAM7C,QAAWqE,EAAKrE,QAC3BuM,EAAYjH,KAAKC,GAAUA,EAAK7D,KAAO,SAClC,MAAM6C,KAAOF,EAAM,OAChBhE,EAASwC,EAAMyC,KAAKC,GAASA,EAAKhC,SAASe,UAAUC,MACrD7C,KAAEA,EAAFI,cAAQA,GAAkBgL,EAAazM,GAC7CmL,EAAOuB,oBAAsBjL,MACxB,IAAI5B,EAAI,EAAGA,EAAIqM,EAAYvM,OAAQE,OAClCiK,EAAIC,SAASmC,EAAYrM,GAAGyC,IAAK,OAC7BgD,EAAQwE,EAAIpI,QAAQwK,EAAYrM,GAAGyC,IACzC4J,EAAYrM,GAAGwB,KAAKC,KAAK,CACvBiB,MAAO2B,EACPxB,MAAOrB,EAAKiE,GAAO9D,KAAM,UAAW,aACjCH,EAAKiE,SAEL,OACC9B,EAAO6C,KAAK2D,QAAQ,CAAE1H,GAAI4J,EAAYrM,GAAGyC,KAC/C4J,EAAYrM,GAAGwB,KAAKC,KAAK,CACvBiB,MAAO2B,EACPxB,MAAO,UACP3B,MAAOyC,EAAKN,SAASe,UAAUC,GAC/B3C,MAAO,EACPC,UAAMrB"}