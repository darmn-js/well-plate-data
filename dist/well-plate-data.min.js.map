{"version":3,"file":"well-plate-data.min.js","sources":["../src/generatePlateLabels.js","../src/well/getRandomId.js","../src/well/well.js","../src/wellPlateData.js"],"sourcesContent":["/**\n * Returns an array of labels as strings\n * @param {object} [options={}]\n * @param {string} [options.nbRows] - Indicates the number of rows that the well plate will contain (if the input is a letter the number of rows will increase alphabetically until it reaches the letter defined as input).\n * @param {string} [options.nbColumns] - Indicates the number of columns that the well plate will contain (if the input is a letter the number of rows will increase alphabetically until it reaches the letter defined as input).\n * @param {number} [options.nbPlates] - Indicates the number of plates to be generated.\n * @param {number} [options.initPlate] - It referes the plate where the experiment began.\n * @param {boolean} [options.accountPreviousWells] - For plates where the well label is a number, this option allows to take in count previous labels in the next plate.\n * @param {string} [options.direction] - For plates where the well label is a number, this option sets the direction in which this will increase.\n * @return {Object} {labelsList, axis }\n */\n\nexport function generatePlateLabels(options = {}) {\n  let {\n    nbRows = 'h',\n    nbColumns = '12',\n    nbPlates = 1,\n    initPlate = 0,\n    accountPreviousWells = false,\n    direction = 'horizontal',\n  } = options;\n\n  let entries = Object.entries({\n    rows: nbRows,\n    columns: nbColumns,\n  });\n\n  for (let i = 0; i < entries.length; i++) {\n    if (Number.isNaN(parseInt(entries[i][1], 10))) {\n      let label = entries[i][1].toUpperCase().charCodeAt(0);\n      let axis = new Array(label - 64)\n        .fill()\n        .map((item, index) => String.fromCharCode(index + 65));\n      entries[i][1] = axis;\n    } else {\n      let axis = new Array(parseInt(entries[i][1], 10))\n        .fill()\n        .map((item, index) => index + 1);\n      entries[i][1] = axis;\n    }\n  }\n  let labelsList = [];\n  let [rows, columns] = [entries[0][1], entries[1][1]];\n  if (Number.isInteger(rows[0]) && Number.isInteger(columns[0])) {\n    let rod = direction === 'vertical' ? rows : columns;\n    for (let u = initPlate; u < initPlate + nbPlates; u++) {\n      for (let i = 0; i < rows.length; i++) {\n        let row = [];\n        for (let j = 0; j < columns.length; j++) {\n          let [rowIndex, columnIndex] =\n            direction === 'vertical' ? [i, j] : [j, i];\n          let factor = accountPreviousWells\n            ? u * rows.length * columns.length\n            : 0;\n          row[j] = `${u + 1}-${\n            factor + (columnIndex * rod.length + rod[rowIndex])\n          }`;\n        }\n        labelsList.push(...row);\n      }\n    }\n  } else {\n    for (let u = initPlate; u < initPlate + nbPlates; u++) {\n      for (let i = 0; i < rows.length; i++) {\n        let row = [];\n        for (let j = 0; j < columns.length; j++) {\n          let element =\n            typeof rows[i] === 'string'\n              ? rows[i] + columns[j]\n              : columns[j] + rows[i];\n          row[j] = `${u + 1}-${element}`;\n        }\n        labelsList.push(...row);\n      }\n    }\n  }\n  return {\n    labelsList: labelsList,\n    axis: entries,\n  };\n}\n","export function getRandomId(options = {}) {\n  const { length = 25 } = options;\n  let result = [];\n  let characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result.push(\n      characters.charAt(Math.floor(Math.random() * charactersLength)),\n    );\n  }\n  return result.join('');\n}\n","import { getRandomId } from './getRandomId';\n\nexport class Well {\n  /**\n   * @param {String} id - Identificator\n   * @param {String} label - Well label\n   * @param {Number} plate - Number of the plate\n   * @param {Object} [data={}] - Spectrum and growth curves data\n   * @param {Object} [data.growthCurve={}]  - Growth curve obtaineed\n   * @param {Array}  [data.growthCurve.x=[]]\n   * @param {Array} [data.growthCurve.y=[]]\n   * @param {Object} [data.spectrum={}]\n   * @param {Array} [data.spectrum.x=[]] - Spectrum obtaineed\n   * @param {Array} [data.spectrum.y=[]]\n   * @param {Object} [options={}]\n   * @param {Object} [options.metadata={}] - Metadata relate to the well\n   * @param {Array} [options.reagents=[]] - Rctants used in the well\n   */\n  constructor(options = {}) {\n    let {\n      id = getRandomId(),\n      label = undefined,\n      plate,\n      metadata = {},\n      reagents = [],\n      results = [],\n      _highlight = getRandomId()\n    } = options;\n    this.id = id;\n    this.selected = false;\n    this.label = label;\n    this.plate = plate;\n    this.results = results;\n    this.metadata = metadata;\n    this.reagents = reagents;\n    this.growthCurve = {};\n    this.spectrum = {};\n    this.growthCurve.x = [];\n    this.growthCurve.y = [];\n    this.spectrum.x = [];\n    this.spectrum.y = [];\n    this._highlight = _highlight;\n  }\n\n  /**\n   * Returns the growth curve\n   * @returns {Array}\n   */\n  getGrowthCurve() {\n    return this.growthCurve;\n  }\n\n  /**\n   * Returns the spectrum\n   * @returns {Array}\n   */\n  getSpectrum() {\n    return this.spectrum;\n  }\n\n  /**\n   * Returns the metadata of the well\n   * @returns {Object}\n   */\n  getMetadata() {\n    return this.metadata;\n  }\n\n  /**\n   * Returns the reagents presents in the well\n   * @returns {Object}\n   */\n  getReagents() {\n    return this.reagents;\n  }\n\n  /**\n   * Returns the label of the well\n   * @returns {Object}\n   */\n  getLabel() {\n    return this.label;\n  }\n\n  /**\n   * Returns the id of the well\n   * @returns {Object}\n   */\n  getID() {\n    return this.id;\n  }\n\n  /**\n   * Set the growth curve obtained from the well\n   * @param {Object} input\n   * @param {Array} [input.x=[]]\n   * @param {Array} [input.y=[]]\n   */\n\n  addGrowthCurve(growthCurve) {\n    if (!Array.isArray(growthCurve.x) || !Array.isArray(growthCurve.y)) {\n      throw new Error(`X and Y must be arrays`);\n    }\n    this.growthCurve = growthCurve;\n  }\n\n  /**\n   * Set the spectrum obtained from the well\n   * @param {Object} input\n   * @param {Array} [input.x=[]]\n   * @param {Array} [input.y=[]]\n   */\n  addSpectrum(spectrum) {\n    if (!Array.isArray(spectrum.x) || !Array.isArray(spectrum.y)) {\n      throw new Error(`X and Y must be arrays`);\n    }\n    this.spectrum = spectrum;\n  }\n\n  /**\n   * Sets the reagents constituent of the well\n   * @param {Object} reagents - Array of reagents as objects\n   */\n  addReagents(reagents) {\n    if (!Array.isArray(reagents)) {\n      throw new Error(`Reagents must be a vector of objects`);\n    }\n    if (this.reagents.length === 0) {\n      this.reagents = reagents;\n    } else {\n      let newReagents = [];\n      for (let i = 0; i < reagents.length; i++) {\n        let previousReagents = this.reagents[i] ? this.reagents[i] : {};\n        newReagents.push(Object.assign({}, previousReagents, reagents[i]));\n      }\n      this.reagents = newReagents;\n    }\n  }\n\n  /**\n   * Sets the reagents constituent of the well\n   * @param {Object} reagents - Array of reagents as objects\n   */\n  updateReagents(reagents) {\n    if (!Array.isArray(reagents)) {\n      throw new Error(`Reagents must be a vector of objects`);\n    }\n    let newReagents = [];\n    for (let reagent of reagents) {\n      let previousReagent = this.reagents.filter((item) => item.label === reagent.label)[0];\n      newReagents.push(Object.assign({}, previousReagent, reagent));\n    }\n    this.reagents = newReagents;\n  }\n\n  /**\n   * Adds results to the well\n   * @param {Array} result - Object containing the results\n   */\n  addResults(result) {\n    if (Array.isArray(result) || typeof result !== 'object') {\n      throw new Error(`Result must be a object`);\n    }\n    if (!result.name || !result.value) {\n      throw new Error('The name or the value of the result is not defined');\n    }\n    this.results.push(result);\n  }\n}\n","import { generatePlateLabels } from './generatePlateLabels';\nimport { Well } from './well/well';\n\nexport class WellPlateData {\n  /**\n   * Manager of the data regarding a well plates\n   * @param {object} [options={}]\n   * @param {string} [options.nbRows] - Indicates the number of rows that the well plate will contain (if the input is a letter the number of rows will increase alphabetically until it reaches the letter defined as input).\n   * @param {string} [options.nbColumns] - Indicates the number of columns that the well plate will contain (if the input is a letter the number of rows will increase alphabetically until it reaches the letter defined as input).\n   * @param {number} [options.nbPlates] - Indicates the number of plates to be generated.\n   * @param {number} [options.initPlate] - It referes the plate where the experiment began.\n   * @param {boolean} [options.accountPreviousWells] - For plates where the well label is a number, this option allows to take in count previous labels in the next plate.\n   * @param {string} [options.direction] - For plates where the well label is a number, this option sets the direction in which this will increase.\n   */\n  constructor(options = {}) {\n    this.wells = [];\n    let plateLabels = generatePlateLabels(options);\n    const labelsList = plateLabels.labelsList;\n    this.plateLabels = labelsList;\n    for (let i = 0; i < labelsList.length; i++) {\n      const label = labelsList[i].split('-');\n      this.wells.push(\n        new Well({\n          id: labelsList[i],\n          plate: label[0],\n          label: label[1],\n          _highlight: i,\n        })\n      );\n    }\n  }\n\n/**\n   * Fills the plate with information coming from external array.\n   * @param {Array} plate - Array containing well data as objects.\n   */\n  fillPlateFromArray(plate) {\n    let wells = [];\n    for (let well of plate) {\n      wells.push(new Well(well))\n    }\n    this.wells = wells;\n  }\n\n  /**\n   * Sets the reagents constituent to each well\n   * @param {Array} reagents - Array containing an array of reagents as objects\n   */\n  addReagentsFromArray(reagents) {\n    if (!Array.isArray(reagents) || this.wells.length !== reagents.length) {\n      throw new Error(\n        `Input array must have the same length as wells in the plate`,\n      );\n    }\n    for (let i = 0; i < this.wells.length; i++) {\n      this.wells[i].addReagents(reagents[i]);\n    }\n  }\n\n  /**\n   * Sets the corresponding spectrum to each well\n   * @param {Array} spectra - Array of objects containing the x and y components of the spectrum\n   */\n  addSpectrumFromArray(spectra) {\n    if (!Array.isArray(spectra) || this.wells.length !== spectra.length) {\n      throw new Error(\n        `Input array must have the same length as wells in the plate`,\n      );\n    }\n    if (\n      !Array.isArray(spectra) ||\n      !Array.isArray(spectra[0].x) ||\n      !Array.isArray(spectra[0].y)\n    ) {\n      throw new Error(\n        `The input array must be an array of objects with x and y components`,\n      );\n    }\n    for (let i = 0; i < this.wells.length; i++) {\n      this.wells[i].addSpectrum(spectra[i]);\n    }\n  }\n\n  /**\n   * Sets the corresponding growth curve to each well\n   * @param {Array} growthCurves - Array of objects containing the x and y components of the growth curve\n   */\n  addGrowthCurvesFromArray(growthCurves) {\n    if (\n      !Array.isArray(growthCurves) ||\n      this.wells.length !== growthCurves.length\n    ) {\n      throw new Error(\n        `The input array must have the same length as wells in the plate`,\n      );\n    }\n\n    if (\n      !Array.isArray(growthCurves) ||\n      !Array.isArray(growthCurves[0].x) ||\n      !Array.isArray(growthCurves[0].y) ||\n      growthCurves[0].y.length !== growthCurves[0].x.length\n    ) {\n      throw new Error(\n        `The input array must be an array of objects with x and y components`,\n      );\n    }\n    for (let i = 0; i < this.wells.length; i++) {\n      this.wells[i].addGrowthCurve(growthCurves[i]);\n    }\n  }\n\n  /**\n   * Sets the corresponding result to each well\n   * @param {Array} results - Array of objects containing the results added\n   */\n  addResultsFromArray(results) {\n    if (!Array.isArray(results)) {\n      throw new Error('The results input is not an array');\n    }\n    for (let i = 0; i < this.wells.length; i++) {\n      this.wells[i].addResults(results[i]);\n    }\n  }\n\n  /**\n   * Returns an array of objects with the corresponding labels to each well\n   * @returns {Array}\n   */\n  getPlateTemplate() {\n    return this.plateLabels.map((item, index) => ({\n      index: index,\n      label: item,\n      selected: false,\n      _highlight: index\n    }));\n  }\n\n  /**\n   * Returns an array of objects containing IDs of the wells with the same reagents and the corresponding key reagents\n   * @returns {Array}\n   */\n  getSamplesIDs() {\n    const wells = this.wells;\n    let sampleWells = [];\n    let sampleLabels = [];\n    for (let i = 0; i < wells.length; i++) {\n      let replicated = JSON.stringify(\n        wells[i].reagents.map((item) => item.concentration),\n      );\n      let feature = sampleWells.find((element) => element === replicated);\n      if (feature + 1) continue;\n      sampleWells.push(replicated);\n      const replicatesLabels = wells\n        .filter(\n          (item) =>\n            JSON.stringify(\n              item.reagents.map((element) => element.concentration),\n            ) === replicated,\n        )\n        .map((item) => item.label);\n      sampleLabels.push(replicatesLabels);\n    }\n    return sampleLabels;\n  }\n\n    /**\n   * Returns an array of objects with the corresponding labels to each well\n   * @returns {Array}\n   */\n  getWells(options = {}) {\n    const { ids } = options;\n    let wells = [];\n    for (let well of this.wells) {\n      if (!ids || ids.includes(well.id)) wells.push(well);\n    }\n    return wells;\n  }\n\n      /**\n   * Returns an array of objects with the corresponding labels to each well\n   * @returns {Array}\n   */\n  getWell(options = {}) {\n    const { id } = options;\n    for (let well of this.wells) {\n      if (id === well.id) {\n        return well;\n      }\n    }\n  }\n}\n"],"names":["generatePlateLabels","options","nbRows","nbColumns","nbPlates","initPlate","accountPreviousWells","direction","entries","Object","rows","columns","i","length","Number","isNaN","parseInt","label","toUpperCase","charCodeAt","axis","Array","fill","map","item","index","String","fromCharCode","labelsList","isInteger","rod","u","row","j","rowIndex","columnIndex","factor","push","element","getRandomId","result","characters","charactersLength","charAt","Math","floor","random","join","Well","constructor","id","plate","metadata","reagents","results","_highlight","selected","growthCurve","spectrum","x","y","getGrowthCurve","this","getSpectrum","getMetadata","getReagents","getLabel","getID","addGrowthCurve","isArray","Error","addSpectrum","addReagents","newReagents","previousReagents","assign","updateReagents","reagent","previousReagent","filter","addResults","name","value","wells","plateLabels","split","fillPlateFromArray","well","addReagentsFromArray","addSpectrumFromArray","spectra","addGrowthCurvesFromArray","growthCurves","addResultsFromArray","getPlateTemplate","getSamplesIDs","sampleWells","sampleLabels","replicated","JSON","stringify","concentration","find","replicatesLabels","getWells","ids","includes","getWell"],"mappings":"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"}